<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用面试知识点]]></title>
    <url>%2Fposts%2F43e45135.html</url>
    <content type="text"><![CDATA[知识点缓存方面：1.缓存穿透：​ 描述：请求某个缓存中和数据库中都不存在的值，且数据库中不存在的值不会重新写入缓存，就导致一个可以对数据库进行攻击的漏洞​ 解决方案：对空的数据也进行缓存，设置一个时间较短的过期时间，可以防止攻击用户反复用同一个id暴力攻击；口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；2.缓存雪崩：​ 描述：某一段时间缓存集中过期的情况（可能是某一段时期一起添加进缓存的商品），导致大量数据需要一次重新缓存​ 解决方案：加入缓存的数据尽量设置有一定随机量的过期时间如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中设置热点数据永远不过期。3.缓存击穿​ 描述：指某个请求非常多的热门key（例如一件热卖的商品，或者某个很火的网红），在访问量特别大的收过期，导致瞬间大量请求到了数据库中，导致数据库出现问题​ 解决方案：设置热点数据永远不过期；加互斥锁互斥锁：用来保证在任一时刻，只能有一个线程访问该对象。乐观锁：认为别人不会动自己的数据，不加锁，只检查数据悲观锁：总认为别人会该数据，使用的时候就加锁4.常见缓存服务memcached：redis:1、 Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 105、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复8、Redis支持数据的备份，即master-slave模式的数据备份。不同点存储方式：memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化（笔者注：有快照和AOF日志两种持久化方式，在实际应用的时候，要特别注意配置文件快照参数，要不就很有可能服务器频繁满载做dump）。数据支持类型：redis在数据支持上要比memecache多的多。使用底层模型不同：新版本的redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。运行环境不同：redis目前官方只支持LINUX 上去行，从而省去了对于其它系统的支持，这样的话可以更好的把精力用于本系统 环境上的优化，虽然后来微软有一个小组为其写了补丁。但是没有放到主干上Cookie和Session的区别Cookie:不安全，存在浏览器，最多20个Session：比较安全，访问量增加，较占用性能安全方面：1. 预防SQL注入：sql中的使用到的字段加上反引号过滤用户输入的数据中的非法字符sql中使用到变量的时候，不要拼接SQL，不要直接嵌入到SQL语句，尽量使用参数化语句2. 预防csrf攻击：阻止不明外域的访问同源检测Samesite Cookie：为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie提交时要求附加本域才能获取的信息CSRF Token（不存在cookie中）：加密算法对数据进行加密双重Cookie验证：要求Ajax和表单请求携带一个Cookie中的值。数据库方面1.mysql索引原理：索引的本质就是使用某种算法生成一个文件（理解为字典），使得我们能更快速的去找到想要的数据。2.mysql引擎类型：InnoDB:1支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。MyISAM:1插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。数据库引擎的选择MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。在数据库做主从分离的情况下，经常选择MyISAM作为主库的存储引擎。如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，这时选InnoDB是不错的。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM是最好的选择3.数据库事务：特性原子性要么都成功，要么都失败一致性事务结束后系统状态是一致的，（钱还是那么多钱）隔离性隔离级别| 级别 | 解释 | 缺点 || ——– | ——————————————– | ———————————————————— || 读未提交 | 在其他事务还没提交的时候就去读取 | 会产生脏读，可以看到别人还没提交的事务产生的结果 || 读提交 | 等待事务完成时再去读 | 会产生虚读，即在别的事务开始前（别的事务进行了update操作），和别的事务提交后读取到的数据不一样 || 重复读 | 事务开始之后，就不许其他事务再去做更新操作了 | 会产生幻读，其他事务执行insert的时候还是会导致在该事务前后读取的不一样（下单卖了一台电脑） || 序列化 | 事务串行化顺序执行 | 但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用 |持久性事务一旦提交后，对数据库中的数据改变是永久性的。4. SQL优化：where和group by所使用的字段上加上索引;避免使用select *,使用具体的字段代替;模糊查询时使用“左匹配原则”;尽量避免使用IN、NOT IN 等关键词，会导致数据库引擎放弃索引进行全表扫描;尽量避免使用OR,会导致数据库引擎放弃索引进行全表扫描,可以用union代替or；尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描,可以给字段添加默认值0，对0值进行判断;尽量避免在where条件中等号的左侧进行表达式、内联函数操作5.MySql常用优化方案：加索引是加快查询速度最有效的方案；数据量大的时候要采用分库分表；读写分离。PHP基础知识1.php垃圾回收机制：php7声明一个变量并赋值后，在底层C实现是一个zval结构体和zend_value到的联合体，1234567891011$a = "abc916"zval &#123; string "a" //变量的名字是a value zend_value //变量的值 type string //变量是字符串类型&#125;zend_value &#123; string "abc916" //值的内容 refcount 1 //引用计数 &#125;引用计数：被引用的内存块有一个计数器refcount，用于记录被变量引用的次数，在他的计数器为0时内存即被释放,但是对于变量的循环引用依然会导致内存泄露，例如：1234&lt;?php $a = array('hahah'); //此时array对象的引用次数为1，‘one’的引用次数为1 $a[] = &amp;$a; //此时array对象的引用次数为2，‘one’的引用次数为1 unset($a); //此时array对象的引用次数为1，‘one’的引用次数为1,由于变量指针被销毁，这时这个array就会无法访问导致内存泄漏产生垃圾的情况数组：a数组的某个成员使用&amp;引用a自己对象：对象的某个成员引用对象自己垃圾回收原理：1、以php的引用计数机制为基础（php5.3以前只有该机制）2、同时使用根缓冲区机制，当php发现有存在循环引用的zval时，就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量后，就会进行垃圾回收，以此解决循环引用导致的内存泄漏问题（php5.3开始引入该机制）2. 常用魔术方法：__call()调用一个类中不存在的方法的时候运行__toString()当一个类的实例对象；被当成一个字符串输出时调用__isset()当对不可访问的私有属性使用isset或empty时自动调用__invoke()调用函数的方式调用一个对象时的回应方法__autoload()尝试加载未定义的类并发方面1.响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。2.吞吐量：单位时间内处理的请求数量。3.QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。4.并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。算法题：01背包问题：动态规划12345678910111213141516171819def bag(n, c, w, v): """ 测试数据： n = 6 物品的数量， c = 10 书包能承受的重量， w = [2, 2, 3, 1, 5, 2] 每个物品的重量， v = [2, 3, 1, 5, 4, 3] 每个物品的价值 """ # 置零，表示初始状态 value = [[0 for j in range(c + 1)] for i in range(n + 1)] for i in range(1, n + 1): for j in range(1, c + 1): value[i][j] = value[i - 1][j] # 背包总容量够放当前物体，遍历前一个状态考虑是否置换 if j &gt;= w[i - 1] and value[i][j] &lt; value[i - 1][j - w[i - 1]] + v[i - 1]: value[i][j] = value[i - 1][j - w[i - 1]] + v[i - 1] for x in value: print(x) return value最长回文子串：动态规划123456789101112131415161718class Solution: def longestPalindrome(self, s: str) -&gt; str: size = len(s) if size &lt;= 1: return s dp = [[False for _ in range(size)] for _ in range(size)] longest_l = 1 res = s[0] for r in range(1, size): for l in range(r): if s[l] == s[r] and (r - l &lt;= 2 or dp[l + 1][r - 1]): dp[l][r] = True cur_len = r - l + 1 if cur_len &gt; longest_l: longest_l = cur_len res = s[l:r + 1] return res基于快速排序输入一组逗号分割的数，将这组数组合成为一个最小的数。123456如输入：123,22,32输出：1232232输入：210,21,11,12输出：111221021123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpfunction mySort($a,$b)&#123; $f_a = (int)substr( $a, 0, 1 ); $f_b = (int)substr( $b, 0, 1 ); if($f_a==$f_b)&#123; $resa = (int)($a.''.$b); $resb = (int)($b.''.$a); if($resa&gt;$resb)&#123; return 1; &#125;else&#123; return 0; &#125; &#125; if($f_a&gt;$f_b)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;function quicksort($left,$right,&amp;$arr)&#123; if($left&gt;$right)&#123; return; &#125; $a = $arr[$left]; $i = $left; $j = $right; while ((int)$i != (int)$j)&#123; while(mySort($arr[$j],$a) &amp;&amp; $i &lt; $j)&#123; $j --; &#125; while ((!mySort($arr[$i],$a)) &amp;&amp; $i&lt;$j) &#123; $i ++; &#125; if($i&lt;$j)&#123; $t = $arr[$i]; $arr[$i] = $arr[$j]; $arr[$j] = $t; &#125; &#125; $arr[$left] = $arr[$i]; $arr[$i] = $a; #更換基準數 quicksort($left,$i-1,$arr); quicksort($i+1,$right,$arr);&#125;$arr = array('125','12','3','31');quicksort(0,3,$arr);print_r($arr);]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之配置]]></title>
    <url>%2Fposts%2Ff8ae19a9.html</url>
    <content type="text"><![CDATA[pom.xml文件定义各种项目中使用到的版本依赖，导入大部分依赖不需要写版本号1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;spring-boot-starter:场景启动器，导入web模块的所需的组件SpringBoot 将所依赖的功能抽取出来做成了一个个的starter(启动器),项目中引入这些starter,即可自动导入相应依赖（启动器）Application主程序1234567@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;1.@SpringBootApplication注解：说明当前类为主配置类，通过main方法启动SpringBoot应用，点进注解可见如下组合注解123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@SpringBootConfiguration:SpringBoot的配置类，表示这是一个配置类@EnableAutoConfiguration:开启自动配置功能 ：123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)​ @AutoConfigurationPackage:将主配置类的所在包,及以下所有子包的所有组件扫描到spring容器中SpringBoot配置可用XXX.yml文件作为配置文件，用于配置非默认配置值的项目写法1.基本语法：key: (空格)value – 键值对 （大小写敏感）123server: port: 8088 path: /hello2.value写法字面量​ 可使用数字、字符串、布尔​ 字符串默认不用加上双引号或者单引号，双引号不转义特殊字符对象、map:key: value方式123human: name: zhangsan age: 20行内写法：1human: &#123;name: zhangsan,age: 20&#125;数组（List,Set）:12345citys: - shanghai- guangzhou- shengzheng- beijing行内写法：1citys: [shanghai,guangzhou,shengzheng,beijing]配置对应Bean@ConfigurationProperties和@Value注解@ConfigurationProperties(prefix=&quot;human&quot;) 将属性全部注入类的成员变量中（默认从全局配置文件中取值）@Value(&quot;{$huamn.name}&quot;) 一个个属性的注入（一般在业务逻辑中需要使用某项配置值的时候使用，例如某些需要写死的数据临时需要使用）@PropertySource和@ImportResource注解@PropertySource(value = {classpath:person.yml}):(指定配置文件加载）@ImportResource(localtion={&quot;classpath:XXX.xml&quot;}):导入Spring配置文件，让配置文件生效（兼容xml配置文件）SpringBoot推荐给容器添加组件的方式：（使用全注解的方式）配置类加上@Configuration注解使用@Bean添加组件12345678@Configurationpublic calss MyAppConfig()&#123; //将方法返回值添加到容器中，组件默认ID就是方法名 @bean public Myservice myService()&#123; return ; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之HelloWorld]]></title>
    <url>%2Fposts%2F9580d45f.html</url>
    <content type="text"><![CDATA[一.创建SpringBoot项目使用IDEA创建项目二.SpringBoot使用创建项目主程序DemoApplication 类，@SpringBootApplication注解表示这是一个入口主程序12345678910@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)public class DemoApplication &#123; public static void main(String[] args) &#123; // 启动运行当前主程序 SpringApplication.run(DemoApplication.class, args); &#125;&#125;创建IndexController类:在当前包下新建一个Controller类 IndexController类1234567@RestController //表示这是一个控制器public class IndexController &#123; @RequestMapping("/hello") //路由 public String hello()&#123; return "Hello World"; &#125;&#125;运行主程序：SpringBoot内建了tomcat直接可以运行三.部署：将 应用打包为一个jar包，在pom.xml中加入一下配置将spring-boot-maven-plugin添加到项目中12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;保存并运行1mvn package打包完成后可在target目录中看到对应的jar包使用java -jar target/demo-0.0.1-SNAPSHOT.jar命令即可运行jar包]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现动态公网IP下掌握最新IP]]></title>
    <url>%2Fposts%2Ff299d5cf.html</url>
    <content type="text"><![CDATA[上篇博客写到将自己的电脑设置为DMZ主机直接暴露到外网，将自己的主机当作服务器使用，使用过程中发现电信的动态IP经常会更换，而且更换规律捉摸不透，经常因为IP变动导致无法连接到电脑解决方案&emsp;&emsp;遇到这个问题首先被想到的肯定是DDNS服务(动态域名解析)，这的确是个好办法，但是我注册好一个花生壳账号之后，发现我的垃圾路由器并不支持花生壳的DDNS，并且我也不想在我的电脑上安装他的客户端（并且我注册好花生壳后不到三分钟，就有花生壳的人打电话来说让我用付费版，说速度快，让人很反感）&emsp;&emsp;到这里，DDNS这条路我是走不通了，于是我又想出来一个比较简单粗暴地方法，即：在我的电脑上写一个定时任务，获取到当时的公网IP然后再想办法让我能看到这个更新的IP,而coding或者GitHub的pages服务则是可以让我看到我的IP的一个绝佳的方式，可以将获取到的IP写在HTML文件里,再使用git将其推送到远程仓库展示出来,于是写下如下Python程序：123456789101112131415#!/usr/bin/python# -*- coding:utf8 -*-import requests,osimport reurl = requests.get("http://txt.go.sohu.com/ip/soip")#获取当前公网IPtext = url.textip = re.findall(r'\d+.\d+.\d+.\d+',text) #截取出IPos.chdir("E://ip_update//ip_table") #工作目录调整到显示ip的git仓库下r = open(r'.\ip.html','w+')old_ip = r.read()old_ip.replace(" ", "")if old_ip != ip[0]: #新老IP若不一致则写文件，并且更新 r.write(ip[0]) r.close() os.system("git add . &amp;&amp; git commit -m 'update' &amp;&amp; git push origin master")&emsp;&emsp;并且在coding上新开了一个项目,只有一个index.html，用于显示更新IP。&emsp;&emsp;接下来的问题就是让这个python脚本定时运行，这里可以使用windows的任务计划程序完成，过程不再赘述。]]></content>
      <categories>
        <category>随意折腾</category>
      </categories>
      <tags>
        <tag>动态公网IP</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去他的Teamviewer吧——破解天翼网关使用端口映射]]></title>
    <url>%2Fposts%2F1566dc66.html</url>
    <content type="text"><![CDATA[Teamviewer的烦恼平时在外面经常需要远程连接到自己的电脑远程做一些操作，之前一直使用teamviewer，近期不知道为什么我被teamviewer检测为商用了每次只有5分钟的市场非常让人恼火。看了一下官网的价格：这个价格。。。对于习惯了“白嫖”的我们来说就可以直接劝退了。破解光猫超级管理员账号于是乎我想起了找个替代方案，windows的远程桌面似乎就是个不错的选择,但是远程桌面必须是有公网IP才能使用，于是我查询了一下，我的出租房内用的电信宽带居然是独立的静态IP，也就是说只要猫或者路由器支持，就可以使用它的端口映射功能将我的电脑的端口映射到公网上，那样我就能随时随地的远程桌面了，看了一下我电脑连接的猫是个中兴的产品，进入http://192.168.1.1,顺利进入猫的管理登陆页面:试了一下常用的admin账号会用的密码，无果，于是乎搜索一番找到了一个破解中心猫的方法：进入http://192.168.1.1/manager_dev_config_t.gch，如图选择“导出配置”即可导出一个config.bin的猫的配置文件打开http://www.upantool.com/qita/2014/4848.html，下载一个叫做offzip的工具来解压这个配置文件，下载完成后，将解压后的文件和comfig.bin放在一起，打开命令行窗口,输入offzip -a ./config.bin ./ 0得到如下结果，文件夹中会出现一堆文件用文本编辑器依次打开各个文件，查找关键字telecomadmin就可以找到如图所示的内容，password即是猫的超级管理员密码。尝试登陆，成功登陆超级管理员页面。设置主机为DMZ主机或者虚拟服务器DMZ主机指的是位于网关之外的主机，它的所有端口面向公网，这就相当于身为DMZ主机的内网主机拥有了一个公网的IP；虚拟服务器路由器中可以设置虚拟服务器的功能，值得是把某一内网主机的某些端口映射公网上。这台中兴的猫两个功能都支持，不多说了，中兴牛逼;设置位置如下：测试将猫重启之后，在外网尝试远程连接之后，再见吧,Teamviewer!!!]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>远程桌面</tag>
        <tag>天翼网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python实现UDP内网穿透]]></title>
    <url>%2Fposts%2F4e37bb03.html</url>
    <content type="text"><![CDATA[网络编程中，常常使用udp进行数据传输，由于iPv4地址的紧缺，所以路由器上出现了NAT这种折中方案，使得内网中的主机在外网是无法发现的，内网的数据包是由NAT进行端口映射，在发送到公网上。这样就使内网的主机的ip端口是不确定的，公网中的数据包便无法发送进来，尤其在p2p网络中影响较大内网NAT的链接方式由于内网的主机有了一层NAT，主机A和主机B是无法直接的互相发送数据包的，因为他们互相无法知道对方的映射地址内网穿透思路要实现内网穿透，首先肯定是要有一个有公网IP的服务器作为内网主机的引导，使用python.socket完成数据通信，服务器端主要完成以下任务：保存所有连入的主机的IP和端口号；监测心跳信息判断连入的主机是否存活，刷新存活的主机列表；向连入的内网主机发送现有的主机列表。内网的主机需要完成以下任务：连入服务器，向其发送数据包；接收服务器端传回的主机列表，更新主机列表；由于NAT映射存留session时间较短，需间隔几秒向向服务器发送心条信息使用到的数据包：PING： 向指定的主机发送的第一个数据包PONG： 收到其他主机发来的PING数据包返回一个PONG数据包FIND_NODE: 向引导服务器请求获取现有的主机列表HEART: 心跳数据包，向引导服务器证明主机尚存活RESPONSE_NODE:引导服务器向内网主机传回主机列表服务端实现服务端需要两个线程：判断收到的数据包类型，并进行相应操作；定时维护现有的主机列表。实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# -*- coding: utf-8 -*-import socket,time,threading,jsondef headers(data): #解析数据包 header_content = data.split('\r\n\r\n', 1)[0].split('\r\n')[0:] result = &#123;&#125; for line in header_content: k, v = line.split(':',1) result[k.strip(" ")] = v.strip(" ") return resultdef recv_ping(socket,addr): #接收客户端的ping if addr not in nodes: nodes.append(addr) #添加时间戳 alive.append([addr,time.time()]) print("add_new node") send_pong(socket,addr) def send_pong(socket,addr): msg = "Content-Type:PONG\r\n" msg += "ip:"+addr[0]+"\r\n" msg += "port:"+str(addr[1])+"\r\n" msg += "msg:I`m fine!\r\n\r\n" #消息 socket.sendto(msg.encode("utf-8"),addr) #回复Pong print "回应ping" print adddef nodes_back(socket,addr): #服务端返回节点列表 response = "Content-Type:RESPONSE_NODE\r\n" str = json.dumps(nodes) response += "nodes:"+str+"\r\n\r\n" print("返回节点列表") socket.sendto(response,addr)def append_node(addr): if addr not in nodes: send_pong(socket.socket(socket.AF_INET,socket.SOCK_DGRAM),addr) for n in nodes: if n[0] == addr[0]: nodes.pop(nodes.index(n)) #清除旧的addr nodes.append(addr) alive.append([addr,time.time()]) print("add_new node") else: for a in alive: if a[0] == addr: a[1] = time.time() #更新最后链接时间 break;def recv(receive,header,addr): header = headers(header) if header["Content-Type"] == "PING": #收到PING数据 recv_ping(receive,addr) if header["Content-Type"] == "FIND_NODE": nodes_back(receive,addr) if header["Content-Type"] == "HEART": print "heart from" append_node(addr) print addr passdef refrush_nodes(socket): while True: if len(nodes) &gt; 0: print "开始刷新列表" for a in alive: now = time.time() if now - a[1] &gt; 5.0: print "去掉"+a[0][0] nodes.pop(nodes.index(a[0])) #去掉超过5s未连接的客户机 alive.pop(alive.index(a)) for n in nodes: print "刷新列表" nodes_back(socket,n) time.sleep(5)nodes = []alive = []if __name__ == "__main__": addr = ('0.0.0.0',20006) receive = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) receive.bind(addr) print 'Waiting for connection...' t1 = threading.Thread(target=refrush_nodes, args=(receive,)) t1.start() while True: # 接受一个新连接: header,address = receive.recvfrom(2048) # 创建新线程来处理TCP连接: t = threading.Thread(target=recv, args=(receive,header,address)) t.start()其中，使用两个全局变量：nodes和alive分别存储他们的ip、端口信息和最后一次发送心跳HEART数据包的时间，这样就能帅选出已经掉线的主机信息并剔除。服务端操作流程如下所示：内网主机端实现内网主机端需要两个线程：判断收到的数据包类型，并进行相应操作；定时向引导服务器发送HEART心跳数据包。实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# -*- coding: utf-8 -*-import socket,time,threading,jsondef headers(self,data): #解析数据包 header_content = data.split('\r\n\r\n', 1)[0].split('\r\n')[0:] result = &#123;&#125; for line in header_content: k, v = line.split(':',1) result[k.strip(" ")] = v.strip(" ") return resultdef send_ping(socket,addr,msg=""): #send ping #socket.sendto("ping".encode('UTF_8'),addr) request = "Content-Type:PING\r\n" request += "msg:Are you OK!"+msg+"\r\n\r\n" #消息 socket.sendto(request.encode("utf-8"),addr) print("send_ping") print ("发送ping到"+addr[0])def recv_ping(socket,addr): #接收客户端的ping global nodes while True: msg,addr = socket.recvfrom(2048) h = headers(msg) if(addr not in nodes): nodes.append(addr) print("add_new node") msg = "Content-Type:PONG\r\n" msg += "Msg:hello\r\n\r\n" socket.sendto(msg,addr)def get_nodes(socket,addr): #ask to server request = "Content-Type:FIND_NODE\r\n" request += "msg:Are you OK!\r\n\r\n" #消息 print("向请求邻居") print (request) socket.sendto(request.encode("utf-8"),addr)def headers(data): #解析数据包 print(data) data = data.decode("utf-8") header_content = data.split('\r\n\r\n', 1)[0].split('\r\n')[0:] result = &#123;&#125; for line in header_content: k, v = line.split(':',1) result[k.strip(" ")] = v.strip(" ") return resultdef nodes_back(socket,addr): #服务端返回节点列表 response = "Content-Type:RESPONSE_NODE\r\n" socket.sendto()def recv(receive,server_addr): while True: global nodes data,addr = receive.recvfrom(2048) #收到服务器的回应 header = headers(data) if header["Content-Type"] == "PONG" and addr == server_addr: #收到回应的话每隔几秒发送心跳信息 t2 = threading.Thread(target=heart, args=(receive,addr)) t2.start() if header["Content-Type"] == "RESPONSE_NODE": print("收到列表") node_list = json.loads(header["nodes"]) global nodes nodes = [] for value in node_list: t = tuple(value) if value not in nodes and t != myaddr: nodes.append(t) if header["Content-Type"] == "PONG" and addr != server_addr: msg = "Content-Type:NAT\r\n" msg += "msg:success\r\n\r\n" receive.sendto(msg.encode("utf-8"),addr) if header["Content-Type"] == "PING": msg = "Content-Type:PONG\r\n" msg += "msg:success\r\n\r\n" receive.sendto(msg.encode("utf-8"),addr)def heart(socket,addr): #发送心跳 msg = "Content-Type:HEART\r\n" msg += "msg:i'm alive!\r\n\r\n" while True: socket.sendto(msg.encode("utf-8"),addr) time.sleep(3)nodes = []myaddr = ()if __name__ == "__main__": addr = ('47.101.137.17',20006) receive = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) send_ping(receive, addr) #say hello与服务器建立连接 t = threading.Thread(target=recv, args=(receive,addr)) t.start() get_nodes(receive, addr) #获取节点列表 while True: print (nodes) if len(nodes)&gt;0: for i in range(1,len(nodes)): if nodes[i] != myaddr: send_ping(receive,nodes[i],nodes[i][0]) time.sleep(3)其中使用nodes全局变量来存储现有的主机列表内网机端的执行流程如下图所示：结论这么看起来NAT的穿透并不是很复杂，后期NAT穿透可以用于P2P网络的搭建，使得内网也可是使用P2P网络。]]></content>
      <categories>
        <category>Python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>内网穿透</tag>
        <tag>p2p</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加背景轮播图]]></title>
    <url>%2Fposts%2F50d69843.html</url>
    <content type="text"><![CDATA[原生的next主题的背景是纯白的看起来十分的单调，这里使用jquery-backstretch插件可以设置页面的背景图片，来定制化自己的博客。使用插件jquery-backstretchjquery-backstretch是一个简单的可设置动态背景图的插件，可直接使用官网提供的CDN也可下载下来使用。使用方法引入插件cdn创建一个themes\next\layout_custom\custom-foot.swig文件，用于包含一些js文件，在文件中添加：1234&lt;!-- 图片轮播js文件cdn --&gt;&lt;script src="https://cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"&gt;&lt;/script&gt;&lt;!-- 自定义的js文件 --&gt;&lt;script type="text/javascript" src="/js/src/custom.js"&gt;&lt;/script&gt;custom.js中可添加我们自定义的一些js方法，为了正常使用插件，引入的插件需放在custom.js之前，因为在custom.js中需要使用到插件中的方法，这样可能会出现报错。custom-foot.swig保存之后打开themes\next\layout\index.swig,这个文件是整个页面的框架文件，在&lt;/body&gt;标签前插入：1&#123;% include '_custom/custom-foot.swig' %&#125;这样cdn就引入了页面了，以后需要使用的插件也都可以在custom-foot.swig中引入。调用插件的backstretch方法生成轮播图找一些想要的图片，放到source/images/background文件夹中，打开themes\next\source\js\src\custom.js文件，添加如下代码：12345678 /* 轮播背景图片 */$(function () &#123; $.backstretch([ "/images/background/bg1.jpg", "/images/background/bg2.jpg", "/images/background/bg3.jpg" ], &#123; duration: 20000, fade: 1500 &#125;); &#125;);其中参数中的duration是轮播图间隔时间，duration是切换过渡效果的时间。优化显示效果如果背景图太鲜艳，由于文章内容都是白色的容易造成背景图喧宾夺主的感觉，同时由于博客内容的遮挡，图片也只能看到边角，所以这里可以将背景和页面设置为部分透明，只需打开themes\next\source\css\_custom\custom.styl,这个文件是用于一些自定义的css样式,可直接在此修改一些原有标签的样式，在文件中添加：12345678/* 背景图透明度 */.backstretch &#123; opacity: .85;&#125;/* 页面透明度 */.content-wrap, .sidebar &#123; opacity: .9 !important;&#125;这里其实可以在博客中找到指定的空间的class标签,直接在custom.styl重新定义样式就可以把博客自定义成想要的样子啦。参考文章感谢雨临Lewis]]></content>
      <categories>
        <category>hexo博客</category>
        <category>next个性化</category>
      </categories>
      <tags>
        <tag>Next主题</tag>
        <tag>轮播图</tag>
        <tag>个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java/php/Python/Golang性能测试]]></title>
    <url>%2Fposts%2F6573d2e3.html</url>
    <content type="text"><![CDATA[编程语言性能测试各种编程语言之间各自皆有长处，也有短处，速度快的语言必然逃不了强类型、语法复杂等特点，写起来优雅的语言必然面临着速度缓慢的问题。今天我就来测试一下我所熟悉的几种语言的速度究竟如何，这里分别使用JAVA、PHP、Python和Golang四种编程语言进行测试，我写了一个涉及算数操作、字符串、和数据类型转换操作的函数，让他循环执行一百万次来测试程序需要执行多久，下面请看代码：1.java:123456789101112131415161718192021222324252627public class Test&#123; public static void main(String[] args) &#123; long t1 = System.currentTimeMillis(); for(int i=0; i&lt;10000000; i++)&#123; aaa((float)i); &#125; long t2 = System.currentTimeMillis(); System.out.println("java time" + String.valueOf(t2 - t1) + "ms"); &#125; static void aaa(float i)&#123; float a = i + 1; float b = 2.3f; String s = "abcdefkkbghisdfdfdsfds"; if(a &gt; b)&#123; ++a; &#125;else&#123; b = b + 1; &#125; if(a == b)&#123; b = b + 1; &#125; float c = (float) (a * b + a / b - Math.pow(a, 2)); String d = s.substring(0, s.indexOf("kkb")) + String.valueOf(c); &#125;&#125;2.PHP1234567891011121314151617181920212223&lt;?phpfunction aaa($i)&#123; $a = $i + 1; $b = 2.3; $s = "abcdefkkbghisdfdfdsfds"; if($a &gt; $b)&#123; ++$a; &#125;else&#123; $b = $b + 1; &#125; if($a == $b)&#123; $b = $b + 1; &#125; $c = $a * $b + $a / $b - pow($a, 2); $d = substr($s, 0, strpos($s, 'kkb')) . $c;&#125;$t1 = microtime(true);for($i=0; $i&lt;10000000; $i++)&#123; aaa($i);&#125;$t2 = microtime(true);echo 'php time:' . ($t2 - $t1)*1000 . "ms\n";?&gt;3.python:123456789101112131415161718import math,timedef aaa(i): a = i + 1 b = 2.3 s = "abcdefkkbghisdfdfdsfds" if a &gt; b: a = a + 1 else: b = b + 1 if a == b: b = b + 1 c = a * b + a / b - math.pow(a , 2) d = s[0:s.index("kkb")]+str(c)t1 = time.time()for i in range(10000000): aaa(i)t2 = time.time()print("python time :"+str((t2-t1)*1000)+"ms\n")4.Golang1234567891011121314151617181920212223242526272829303132package mainimport ( "time" "math" "strings" "strconv" "fmt") func main() &#123; var t1 int32 = int32(time.Now().UnixNano()/ 1e6) for a := 0; a &lt; 10000000; a++ &#123; aaa(a) &#125; var t2 int32 = int32(time.Now().UnixNano()/ 1e6) fmt.Printf("Go time: %d ms\n", (t2-t1))&#125;func aaa(i int) string&#123; var a = float64(i) + 1 var b float64 = 2.3 var s string= "abcdefkkbghisdfdfdsfds" if a &gt; b&#123; a = a + 1 &#125;else&#123; b = b + 1 &#125; if a == b&#123; b = b + 1 &#125; var c float64 = a * b + a / b - math.Pow(a, 2) var d string = s[0:strings.Index(s, "kkb")] return strconv.FormatFloat(c, 'E', -1, 32)+d&#125;测试环境windows 7 ,inter i3, 4GB内存python3.6 , Golang 1.11.2 , PHP7.2.1 ,JDK1.8测试结果如下：由测试结果可以看出，java毫无悬念的最快，让我没想到的是,我用的php7.2整整比java慢了六七倍，GO语言的确是很强，值得学习，python不出所料的慢。最慢的php和python明显写起来要更加的简洁一点，动态语言带来的好处就是不用过多的去在意一个数据的类型是什么。根据结果得出结论：速度和性能方面：编译型语言&gt;解释型语言，强类型语言&gt;弱类型语言我个人还是蛮喜欢Golang和python的……^_^,虽然我现在是php程序员]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python实现p2p聊天]]></title>
    <url>%2Fposts%2F97adfa45.html</url>
    <content type="text"><![CDATA[P2P是”peer-to-peer”的简称,中文名点对点传输技术,纯点对点网络没有客户端或服务器的概念，只有平等的同级节点，同时对网络上的其它节点充当客户端和服务器。一、需求1.使用python实现P2P聊天室，主要依靠socket来实现通信；2.由于现在我们基本都是使用的局域网ip，所以正真的没有服务端中转通信是不现实的，所以只能采用一个服务端转发来实现点对点通信；3.实现私聊和广播两种聊天功能。二、服务端实现1.socket的初始化：分为导入包、初始化、绑定端口和监听端口几个操作1234import socket //导入socket包s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) //初始化sockets.bind(('0.0.0.0',6666)) //绑定端口s.listen(10) //监听端口2.聊天队列的处理：这里需要使用多线程来处理每一个socket连接，为每个连接的用户提供消息转发服务12345678while True: //等待连接 # 接受一个新连接: sock, addr = s.accept() person.append(&#123;'addr':addr,'sock':sock,'name':''&#125;) # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start()新连接的信息存储在一个list中，首次连接的时候，询问客户机的名称连同socket对象一起存储到list中。3.聊天消息转发的实现：根据用户选择的聊天模式转发给对应的对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input '%-1' to quit,input '%-2' to quit talk." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8')) mode = 0 ##代表当前聊天模式 0：功能选择，1：P2P对话模式，2：广播模式 target = "" while True: data = sock.recv(2048).decode('utf-8') if data[0] == '%': c = data[1:] if c == "public": //选择广播聊天模式 sock.send(b'sys:Ok,you can talk with all of people now.') mode = 2 elif c == "refresh": //刷新聊天列表 online_list = "******************online_list********************\n" for i in range(0, len(person)): online_list += "%d : name:%s ip:%s \n" % (i,person[i]['name'],person[i]['addr'][0]) online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input %-1 to quit." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8')) elif c == "-1": //退出当前聊天模式（广播、私聊） sock.send("bye!".encode('utf-8')) sock.close() mode = 0; break elif c == "-2": //退出聊天 sock.send("sys:already quit talk.".encode('utf-8')) mode = 0 else: c1 = int(c) target = person[c1] mode = 1 else: if mode == 1: //私聊模式 str = "%s(%s):%s\n time:%s" % (name,addr,data,time.time()) target_sock = target['sock'] target_sock.send(str.encode('utf-8')) elif mode == 2: //广播模式 str = "[Radio]%s(%s):%s\n time:%s" % (name,addr,data,time.time()) for i in range(0, len(person)): //向所有节点转发 target_sock = person[i]['sock'] target_sock.send(str.encode('utf-8')) elif mode == 0: online_list = "******************online_list********************\n" for i in range(0, len(person)): online_list += "%d : name:%s ip:%s \n" % (i,person[i]['name'],person[i]['addr'][0]) online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input %-1 to quit." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8'))三、客户端实现客户端只需要一个接收线程和一个发送线程即可12345678910111213141516171819202122232425def recv_message(sock): while True: data = sock.recv(2048).decode('utf-8') //接收消息 print(data) time.sleep(5)def send_message(sock): while True: data = input('speak:') //发送消息 sock.send(data.encode('utf-8')) time.sleep(5) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect(("xxx.xxx.xxx.xxx",6666)) //连接服务端 recv1 = threading.Thread(target=recv_message, args=(s,))send1 = threading.Thread(target=send_message, args=(s,))recv1.start()time.sleep(2)send1.start()recv1.join()send1.join()四、具体代码server.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#!/usr/bin/env python# encoding=utf-8import socketimport threading,timedef tcplink(sock, addr): name="" print('Accept new connection from %s:%s...' % addr) for i in range(0, len(person)): print(person[i]) if addr == person[i]['addr']: if person[i]['name'] == "": print("send hello") sock.send(b'sys:What is your name?') data = sock.recv(2048).decode('utf-8') person[i]['name'] = data name = data break online_list = "******************online_list********************\n" for i in range(0, len(person)): online_list += "%d : name:%s ip:%s \n" % (i,person[i]['name'],person[i]['addr'][0]) online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input '%-1' to quit,input '%-2' to quit talk." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8')) mode = 0 ##代表当前聊天模式 0：功能选择，1：P2P对话模式，2：广播模式 target = "" while True: data = sock.recv(2048).decode('utf-8') if data[0] == '%': c = data[1:] if c == "public": sock.send(b'sys:Ok,you can talk with all of people now.') mode = 2 elif c == "refresh": online_list = "******************online_list********************\n" for i in range(0, len(person)): online_list += "%d : name:%s ip:%s \n" % (i,person[i]['name'],person[i]['addr'][0]) online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input %-1 to quit." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8')) elif c == "-1": sock.send("bye!".encode('utf-8')) sock.close() mode = 0; break elif c == "-2": sock.send("sys:already quit talk.".encode('utf-8')) mode = 0 else: c1 = int(c) target = person[c1] mode = 1 else: if mode == 1: str = "%s(%s):%s\n time:%s" % (name,addr,data,time.time()) target_sock = target['sock'] target_sock.send(str.encode('utf-8')) elif mode == 2: str = "[Radio]%s(%s):%s\n time:%s" % (name,addr,data,time.time()) for i in range(0, len(person)): target_sock = person[i]['sock'] target_sock.send(str.encode('utf-8')) elif mode == 0: online_list = "******************online_list********************\n" for i in range(0, len(person)): online_list += "%d : name:%s ip:%s \n" % (i,person[i]['name'],person[i]['addr'][0]) online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input %-1 to quit." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8')) print(person)s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)person = [] #存储来的人s.bind(('0.0.0.0',6666))s.listen(10)print('Waiting for connection...')while True: # 接受一个新连接: sock, addr = s.accept() person.append(&#123;'addr':addr,'sock':sock,'name':''&#125;) # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start()client.py1234567891011121314151617181920212223242526272829#!/usr/bin/env python# encoding=utf-8import socketimport threading,timefrom multiprocessing import Processimport osdef recv_message(sock): while True: data = sock.recv(2048).decode('utf-8') print(data) time.sleep(5)def send_message(sock): while True: data = input('speak:') sock.send(data.encode('utf-8')) time.sleep(5)s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect(("xxx.xxx.xxx.xxx",6666)) recv1 = threading.Thread(target=recv_message, args=(s,))send1 = threading.Thread(target=send_message, args=(s,))recv1.start()time.sleep(2)send1.start()recv1.join()send1.join()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>p2p,python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈股市和资本市场]]></title>
    <url>%2Fposts%2Ffd58a2b9.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天上午美团点评在港交所成功上市，纵观最近几个月小米、拼多多、美团等互联网企业突然都在扎堆上市，几位大佬纷纷都去各大交易所敲钟，在这之前我只知道公司上市了就说明这个公司很牛逼，还能对外发行股票了，但是我知道股市绝对不是这样简单的，深究之后写下以下见解。问题1.何为股市？2.公司上市代表着什么？3.股市是如何割韭菜的？一、何为股市&emsp;&emsp;股票市场是已经发行的股票转让、买卖和流通的场所，包括交易所市场和场外交易市场两大类别。由于它是建立在发行市场基础上的，因此又称作二级市场。股票市场的结构和交易活动比发行市场（一级市场）更为复杂，其作用和影响力也更大。&emsp;&emsp;股票市场的前身起源于1602年荷兰人在阿姆斯特河大桥上进行荷属东印度公司股票的买卖，股票市场是股票发行和交易的场所，包括发行市场和流通市场两部分。股份公司通过面向社会发行股票，迅速集中大量资金，实现生产的规模经营；而社会上分散的资金盈余者本着“利益共享、风险共担”的原则投资股份公司，谋求财富的增值。 –百度百科从百度百科的介绍来看可以确定这稳妥妥的就是万恶的资本主义产物了&emsp;&emsp;不过小平爷爷说过：“市场经济不等于资本主义，社会主义也有市场”，虽然股票市场是由资本主义发明，但不是资本主义的代表。通俗的说，股市就是一个赌场，但是他的筹码是企业的价值，投资者觉得某个公司大有可为，在未来的价值会越来越高，就会买入他的股票等待着自己资产升值有空继续写]]></content>
      <tags>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python和gitlab的webhook完成git的自动部署]]></title>
    <url>%2Fposts%2F8d538eb8.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;大部分公司的代码版本控制都是采用git,基本都是采用自己搭建一个gitlab的方式来协同开发，一般代码仓库和项目不会放在用一个目录中，程序员写好代码提交之后就不方便直接部署到服务器上.&emsp;&emsp;gitlab和github等一众平台都提供了一个功能叫webhook,可以配置一个地址和口令，每次有push请求或者其他请求时，gitlab就会向用户所提供的地址放一个GET请求的数据包，这样就可以在项目中写一个webhook的接口来处理push请求，我认为在项目上直接写一个这样的接口不太好，可以采用socket解析数据包的内容来完成代码如下：1234567891011121314151617181920212223242526272829import socket,osimport json,timefrom config import *from urllib import *def headers(data): #解析数据包 header_content = data.split('\r\n\r\n', 1)[0].split('\r\n')[1:] result = &#123;&#125; for line in header_content: k, v = line.split(': ') result[quote(k)] = quote(v) return results = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #建立sockets.bind(('0.0.0.0',10987)) #绑定socket端口s.listen(10)print "waiting connect"while True: sock, addr = s.accept() res = sock.recv(4096).decode('utf-8') header = headers(res) if "X-Gitlab-Token" in header.keys(): if header["X-Gitlab-Token"] == "istillloveyou": if header["X-Gitlab-Event"] == "Push%20Hook": os.system("cd %s &amp;&amp; git pull origin master" % config["project_path"]) print time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) print "**************************************************************"]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python批量修改文件的关键字]]></title>
    <url>%2Fposts%2Fbd6f75fc.html</url>
    <content type="text"><![CDATA[人生苦短，我用pythonpython真的是一个非常实用且轻便的语言，今天在公司里前端写了一堆页面之后,经理看完效果之后突然来了一句：“这个页面里面所有的‘见习’要改成‘实习’哎” 前端听完露出了一万头草拟马奔驰而过的表情，毕竟一堆页面在那。我在旁边听完之后心想，这可得我来露一手了。于是乎，我捧出我心爱的Python，洋洋洒洒写了一个脚本,其实是个特别简单的程序，记得大一时用C语言就应该写过类似的程序，只是现在C语言可能早已忘到天边了，主要就是递归遍历文件夹中的所有文件，将每个文件中的指定关键字切换。递归遍历文件夹：使用Python的os.listdir()方法列出当前文件夹下的所有元素，若是文件夹继续遍历替换文件关键字：open()打开文件使用read()函数读取内容注意文件的编码,这里要使用decode()转换成utf8格式,保证编码不会出问题。以下为全部代码:12345678910111213141516171819import osdef getAllfileAndDirPath(sourcePath): if not os.path.exists(sourcePath): return listName = os.listdir(sourcePath) for name in listName: absPath = os.path.join(sourcePath,name) if os.path.isfile(absPath): if absPath.find('.') != -1 and absPath[absPath.find('.') :] == ".php": with open(absPath,'rb+') as f: t = f.read().decode('utf8') t = t.replace("见习",,"实习") f.seek(0,0) f.write(t.encode('utf8')) print("修改%s完成" % absPath) if os.path.isdir(absPath): getAllfileAndDirPath(absPath)getAllfileAndDirPath(r'test')]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客之Hello World]]></title>
    <url>%2Fposts%2Fcd0da4fc.html</url>
    <content type="text"><![CDATA[1.Hello World!&emsp;&emsp;如果你想写博客玩儿的话，那么有两种方式：使用CSDN等博客网站和自己搭建一个博客，搭建博客的话不用买服务器那是最棒的2.搭建博客&emsp;&emsp;博客对于一个高逼格程序员有以下作用：整理知识，学习笔记发布日记，杂文，所见所想完善自己的知识体系方便回顾自己的学习历程创建github账号&emsp;&emsp;总之养成写博客的习惯对于自身的学习还是很有用处，利用github+Hexo搭建博客首先当然是要有一个github账号啦，这里不多说，直接前往Github注册一个账号，然后下载git客户端巴拉巴拉巴拉，网上这类教程一堆，我也懒得去抄了、、、安装node.js环境&emsp;&emsp;git搞定之后接下来就是配置hexo博客了，hexo博客是基于node.js的一款优秀的开源博客系统，首先安装node.js环境，前往node.js官网http://nodejs.cn/下载对应的系统的安装包，安装完成之后在命令行键入1node -v有出现如下的node.js版本信息即为安装成功&emsp;&emsp;&emsp;&emsp;安装hexo博客&emsp;&emsp;接下来就是要安装hexo了，hexo可以使用node.js的npm包管理器来安装，这里建议先将npm的源换为国内源，这样就不会下载速度巨慢了。国内淘宝源还是不错的，在命令行窗口中输入如下命令：1234npm config set registry https://registry.npm.taobao.org// 配置后可通过下面方式来验证是否成功npm config get registry// 或npm info express然后键入1npm install -g hexo安装完成之后键入 hexo -v 出现版本信息即为安装成功。下面来建立博客，进入想要新建博客的位置，在命令行进行如下操作：1hexo init这时该目录下就会生成一些博客的源文件，如图所示：至此博客建立就基本完成了，下面就是将博客编译运行起来并且发布到github的pages仓库中去。发布博客&emsp;&emsp;首先在github上建立Repository，名称必须与你用户名对应的仓库，仓库名为【your_user_name.github.io】&emsp;&emsp;然后，进入刚刚新建的博客目录中，找到博客根目录下的_config.yml文件，翻倒文件最下面 ，改成：123456deploy: type: git repo: https://github.com/leopardpan/yourname.github.io.git #你的github仓库的地址 branch: master #分支名然后执行命令：1npm install hexo-deployer-git --save然后继续执行命令12hexo g //编译生成静态博客页面hexo d //发布到github仓库中也可以直接执行1hexo d -g&emsp;&emsp;到此为止博客搭建就算完成啦。但是这样博客还是蛮丑的，可以采用第三方的主题来美化博客，我使用的是NexT主题，可以参照NexT官网文档来进一步配置http://theme-next.iissnan.com/。]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>helloworld,搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试博客]]></title>
    <url>%2Fposts%2Fd9407122.html</url>
    <content type="text"><![CDATA[这是一个测试文章第一篇测试文章，哈哈哈！]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
