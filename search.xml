<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[每日算法0113]]></title>
    <url>%2Fposts%2F9e70f0c9.html</url>
    <content type="text"><![CDATA[今日无废话今日题目：给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。示例 1：输入：nums = [1,2,3,4,5]输出：true示例 2：输入：nums = [5,4,3,2,1]输出：false示例 3：输入：nums = [2,1,5,0,4,6]输出：true题解这题可以有两种解法：1 双向遍历找最大最小值更具题意，是需要找出一个递增的三位数，那么思考可得，我要找的这个数nums[i]一定满足下面的条件min(nums[:i-1]) &lt; nums[i] &lt; max(nums[i+1:])比左边的最小值大和比右边的最大值小那么这题就可先找出数字从左往右每一位左侧的最小值和右侧的最大值所以就可以用两个数组分别存储 min(nums[:i-1]) 和 max(nums[i+1:])代码如下：12345678910111213141516171819202122232425262728293031323334func increasingTriplet(nums []int) bool &#123; n := len(nums) if n &lt; 3 &#123; return false &#125; //存储每一位左侧最小值 lminArr := make([]int,n) //存储每一位右侧最大值 rmaxArr := make([]int,n) lminArr[0] = nums[0] for i := 1 ;i&lt;n;i++&#123; if nums[i-1] &gt; lminArr[i-1] &#123; lminArr[i] = lminArr[i-1] &#125;else&#123; lminArr[i] = nums[i-1] &#125; &#125; rmaxArr[n-1] = nums[n-1] for i := n-2 ;i&gt;=0;i--&#123; if nums[i+1] &lt; rmaxArr[i+1] &#123; rmaxArr[i] = rmaxArr[i+1] &#125;else&#123; rmaxArr[i] = nums[i+1] &#125; &#125; for i := 1; i&lt;n-1;i++&#123; //满足min(nums[:i-1]) &lt; nums[i] &lt; max(nums[i+1:]) if nums[i]&gt;lminArr[i] &amp;&amp; nums[i]&lt;rmaxArr[i] &#123; return true &#125; &#125; return false&#125;2 贪心法题目要求找出3个递增数组，那么我们就在数组中维护first和second 两个变量，满足first &lt; second那么只要遍历过程中找到一个nums[i]&gt;second 就说明数组中存在三位的递增数字思路为：初始化first=nums[0] second=INTMAX 开始遍历数组遍历过程中发现有元素大于second则说明存在三位递增数second则在遇到有大于first的元素时赋值为该元素若遇到小于等于first的元素，则将first赋值为该元素看完上面的思路可能会出现一些疑惑，我这样去维护first和second两个元素是当前最小的两个数字，他们并非是递增的，这样判断可能并不准确但是仔细想一下第二步的判断逻辑可知，总是在出现大于second的数是判定为有递增数，既然出现了second那么在他的前面（左侧）肯定是有一个比他更小的数第三步和第四步则是在保障second的前面一定有一个比他小的数字，因为它只在大于第一个数的时候才会更新赋值代码如下：1234567891011121314151617func increasingTriplet(nums []int) bool &#123; n := len(nums) if n &lt; 3 &#123; return false &#125; first, second := nums[0], math.MaxInt32 for i := 1; i &lt; n; i++ &#123; if nums[i] &gt; second &#123; return true &#125; else if nums[i] &gt; first &#123; second = nums[i] &#125; else &#123; first = nums[i] &#125; &#125; return false&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日算法-第一个不存在的大于K的数]]></title>
    <url>%2Fposts%2Fd171b32d.html</url>
    <content type="text"><![CDATA[最近一周好忙，一天天的都在卷，一周都没有更新🤨~最近有一个想法，最近更加深刻的感受到自己的英语水平实在太差了，后续考虑整一个双语言版博客，可能是这一类的技术博客强制自己写一般英文版本的，或是其他板块做成双语🙈~It’s been a busy week，working overtime everyday,so I didn’t write anything🤨~I had an idea recently, because of my terrible english. I am planning to make a dual language blog，maby write some technology blog or other thing，to improve my English skills 🙈~今日题目今天来一题不记得哪里看来的题目：给定一个数组，已知数组（无序）中有n个元素，给定一个k（K&gt;0），求再数组中不存在的第一个比k大的数示例：n=6 k=6数组： [2,5,16,2,4]则第一个不存在于数组中的比k大的数就是7题解这一题第一眼看到，最简单的写法肯定是将数组进行排序就可以找到结果，但是这样时间复杂度就会偏高这里我有一个比较骚一点的思路可以介绍一波：题为找比K大的数实际可以理解为数组中有大于k连续间隔大于1的“空隙”，所以可以将数组中小于k的数全部剔除，将其替换为0，同时已知数组有n个元素所以数组中大于等于k+n的数对于找目标数字也没有意义,也替换为0这里解释一下：因为就算k是数组中最小的数，就算数组中所有的数都可以组成以1递增的数组的话，最大也就到k+n，大于k+n的数字之前肯定就有间隔大于1的&quot;空隙&quot;了剩下的数字里面可以发现于k的差都会在0~n-1之间，骚的地方来了，我们发现，这里可以利用数组的下标来标识，目标数字与k的差，这里我就可以把，与k差为0的放在数字下标为0的位置，1的位置等等等…如果碰到该位置上有非0的数据,则直接调换位置，待后面继续放置所以这个算法就可以分为以下几步：遍历数组，去除&lt;n和&gt;k+n数遍历数组，遇到非0数，与k求差，放到差值的下标如果下标位置有数字，则交换位置，从位置较小的下标继续往后遍历遍历数组，找到第一个为0的下标，这里的下标加上k就是要找的数了代码1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( "fmt")var res [][]intfunc main()&#123; n := 6 a := []int&#123;2,5,15,6,2,4&#125; k := 5 for i:=0;i&lt;n;i++&#123; if a[i] &lt;= k || a[i] &gt;= k+n &#123; a[i] = 0 &#125; &#125; for i:=0;i&lt;n;i++&#123; if a[i] != 0 &#123; chageIndex := a[i] - k tmp :=a[i] a[i] = a[chageIndex] a[chageIndex] = tmp if chageIndex &lt; i&#123; i= chageIndex &#125; &#125; &#125; res := 0 for i:=0;i&lt;n;i++&#123; if i == n-1 || (a[i] != 0 &amp;&amp; a[i+1] == 0)&#123; res = a[i]+1 break &#125; &#125; fmt.Println(res)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[每日算法-全排列]]></title>
    <url>%2Fposts%2F9cf1b2be.html</url>
    <content type="text"><![CDATA[今日题目给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。示例 1：输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]示例 2：输入：nums = [0,1]输出：[[0,1],[1,0]]示例 3：输入：nums = [1]输出：[[1]]题解这一题涉及一个概念全排列名词解释从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。公式：全排列数f(n)=n!(定义0!=1)，如1,2,3三个元素的全排列为：1,2,3 1,3,2 2,1,3 2,3,1 3,1,2 3,2,1共3 * 2 * 1=6种。思路因为本题要求的是全排列，全排列可以使用回溯的思路来做，如下图所示，这是1，2，3三个数字的一个全排列的图解可以看到，第一层为第一个数字，这一层有三个数字可以选择，第二层则只有两个数字可选，红色的箭头遍历到3的时候，已经到了这棵树的叶子节点，所以需要回到之前遍历的位置由于2没有其他叶子节点，所以直接回溯到了1，再接着如下图遍历1的另一个叶子节点所以这题可以使用递归的方式来完成这里可以优化一下算法，例如上面的例子，一个数组[1,2,3]假设将第一个数字放上下标为1的数字2的时候，那么就意味着，第二个数字若选择填写下标为1的1，只需将下标0和1的数字调换顺序即可；同理，若第二个数字选择下标为2的3的时候，只需将下标0和2的数字调换顺序即可；在回溯的时候，只需要将上面的对于元素在交换回来再进行下一步递归即可首先，递归的跳出条件：遍历到了叶子节点，则会跳出，在数组中则是我交换的两个下标相等，则说明遍历到了叶子节点递归参数：数组a,当前遍历到的第几个数字（这里即是数组的下标）和数组长度代码：12345678910111213141516171819202122var res [][]intfunc permute(nums []int) [][]int &#123; res = make([][]int,0) perm(nums,0,len(nums)-1) return res&#125;func perm(a []int, l, r int) &#123; if l == r &#123; b := make([]int, len(a)) copy(b, a[0:]) res = append(res, b) &#125; else &#123; for i := l; i &lt;= r; i++ &#123; tmp := a[l] //交换当前位置的数字和我希望放在当前位置上的数字 a[l] = a[i] a[i] = tmp perm(a, l+1, r) a[i] = a[l] // 到了叶子节点回溯到上一次交换之前，可以理解为恢复现场 a[l] = tmp &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日算法-反转链表]]></title>
    <url>%2Fposts%2Faa43c13c.html</url>
    <content type="text"><![CDATA[今日题目：今天来一题常见的，面试中可能会经常遇到的面试题定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL题解这一题识别常见的议题算法题，主要考的是对于链表这种数据结构的掌握链表结构如下图所示我们需要做的就是，把每一个节点的Next节点指向他的上一个节点由于这是一个单向链表，所以再遍历链表的时候就需要有一个额外的变量`last`用来保存每次遍历节点的上一个节点；再将当前的节点的Next指针指向last, 需要注意的是，由于我们更改了当前的元素的Next,原本指向链表的下一个元素就会丢失，所以需要再之前存储下当前节点的下一个节点所以，基本步骤为：缓存当前节点的下一个节点nextPoint将当前节点的Next指向last将last指向当前节点,用于下一次遍历将当前遍历指针指向nextPoint代码实现12345678910111213141516171819202122/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func reverseList(head *ListNode) *ListNode &#123; p:=head var last *ListNode for p != nil&#123; nextPoint := p.Next //缓存下一个节点 if p == head &#123; //第一个节点特殊处理 p.Next = nil &#125;else&#123; p.Next = last //当前节点指向上一个节点 &#125; last = p //缓存上一个节点 p = nextPoint //继续遍历下一个节点 &#125; return last&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日算法-计算x的n次幂]]></title>
    <url>%2Fposts%2Fd4f2bd81.html</url>
    <content type="text"><![CDATA[决定从今天起开始每天更新一些算法题，通过自己写下来的方式加深印象,加油🤔今日题目：实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。示例 ：123&gt; 输入：x = 2.00000, n = 10&gt; 输出：1024.00000&gt;123&gt; 输入：x = 2.10000, n = 3&gt; 输出：9.26100&gt;题解：这一题看上去是个算法题，其实考的是初中的数学知识，x^n = x^a * x^b (a+b=x)即 x^10 = x^5 * x^2 * x这里可以看出来出来，这可以使用分治的思想，使用一个递归写出来；思路：递归参数：x 求幂的数，以及所求的幂次方，传参时间次方数/2递归中需判断当前n的奇偶，若n为奇数，则需要返回上一次递归的结果相乘再*一个x，因为n/2求整再下一次循环会损失一次方，所以需要在这里乘上递归的跳出条件：次方数计算到了0次方，则返回1,因为x^0=1补充可能遗忘的基础知识(反正我是忘了😭)：计算x的负数次方公式： 1/x^-n(n&lt;0)代码：123456789101112131415161718func myPow(x float64, n int) float64 &#123; if n &gt;= 0 &#123; return calcuPow(x, n) &#125; return 1.0 / calcuPow(x, -n)&#125;func calcuPow(float64 x, n int) &#123; if n == 0 &#123; return 1 &#125; y := calcuPow(x,n/2) res := y*y if n % 2 == 1 &#123; res = res * x &#125; return res&#125;上述题目的变种题：计算 a^b 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。示例123&gt; 输入：a = 2, b = [3]&gt; 输出：8&gt;1234&gt; 输入：a = 2, b = [1,0,2,4]&gt; 输出：457&gt; &gt;题解这题与上述题目类似，也是议题考初中基础的题，首先求幂次方可以使用上题的方式实现，下面说一下这个数组的幂次方如何实现由题意可知，数组[1,0,2,4]这个数组中对应的1204 = (1x1000) + (0x100) + (2 x 10)+(4x1)则a^1024 = a^(1000+20+4) = (a^1000) * (a^20) * (a^4)​ = (a1000)1 * (a10)2 * (a^1)4思路：上述推理可知，我们只需要，从后向前便利次方数组，用每一位上对应权重的 a(10I) 与对应元素位求幂即可这里写的快速幂方法是迭代写法，他的思路其实和递归写法一致，遇到奇数的时候就需要多乘一次a代码如下：123456789101112131415161718192021222324func pow(a,n int) int&#123; res := 1 for ;n &gt; 0;n = n/2 &#123; if n &amp; 1 &gt; 0 &#123; //奇数 res = res * a % 1337 &#125; a = a * a % 1337 &#125; return res&#125;func superPow(a int ,b[] int) int &#123; res := 1 for i:= len(b)-1;i&gt;=0;i-- &#123; if b[i] == 0 &#123; a = pow(a,10) continue &#125; // 上述推导的公式计算(a^n)^b[i] res = res * pow(a,b[i]) % 1337 a = pow(a,10) &#125; return res&#125;]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用面试知识点]]></title>
    <url>%2Fposts%2F43e45135.html</url>
    <content type="text"><![CDATA[知识点缓存方面：1.缓存穿透：描述：请求某个缓存中和数据库中都不存在的值，且数据库中不存在的值不会重新写入缓存，就导致一个可以对数据库进行攻击的漏洞解决方案：对空的数据也进行缓存，设置一个时间较短的过期时间，可以防止攻击用户反复用同一个id暴力攻击；口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；2.缓存雪崩：描述：某一段时间缓存集中过期的情况（可能是某一段时期一起添加进缓存的商品），导致大量数据需要一次重新缓存解决方案：加入缓存的数据尽量设置有一定随机量的过期时间如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中设置热点数据永远不过期。3.缓存击穿描述：指某个请求非常多的热门key（例如一件热卖的商品，或者某个很火的网红），在访问量特别大的收过期，导致瞬间大量请求到了数据库中，导致数据库出现问题解决方案：设置热点数据永远不过期；加互斥锁互斥锁：用来保证在任一时刻，只能有一个线程访问该对象。乐观锁：认为别人不会动自己的数据，不加锁，只检查数据悲观锁：总认为别人会该数据，使用的时候就加锁4.常见缓存服务memcached：redis:1、 Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 105、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复8、Redis支持数据的备份，即master-slave模式的数据备份。不同点存储方式：memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化（笔者注：有快照和AOF日志两种持久化方式，在实际应用的时候，要特别注意配置文件快照参数，要不就很有可能服务器频繁满载做dump）。数据支持类型：redis在数据支持上要比memecache多的多。使用底层模型不同：新版本的redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。运行环境不同：redis目前官方只支持LINUX 上去行，从而省去了对于其它系统的支持，这样的话可以更好的把精力用于本系统 环境上的优化，虽然后来微软有一个小组为其写了补丁。但是没有放到主干上5.Redis的事务特点redis事务为串行执行一串命令，他以 multi 标记开始 后续输入的命令 都会被加入到执行队列中，执行exec命令后队列中所有命令都会被执行若放入执行队列中的命令有出现语法错误，则所有命令都不会执行，若命令中有执行错误命令，则命令队列中错误命令不执行，其余命令正常执行，出现错误需要手动回滚开始事务之前使用watch命令可监控一个(或多个) key，类似数据库中的乐观锁，若指定key发生变更则事务会被打断Cookie和Session的区别Cookie:不安全，存在浏览器，最多20个Session：比较安全，访问量增加，较占用性能安全方面：1. 预防SQL注入：sql中的使用到的字段加上反引号过滤用户输入的数据中的非法字符sql中使用到变量的时候，不要拼接SQL，不要直接嵌入到SQL语句，尽量使用参数化语句2. 预防csrf攻击：阻止不明外域的访问同源检测Samesite Cookie：为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie提交时要求附加本域才能获取的信息CSRF Token（不存在cookie中）：加密算法对数据进行加密双重Cookie验证：要求Ajax和表单请求携带一个Cookie中的值。数据库方面1.mysql索引原理：索引的本质就是使用某种算法生成一个文件（理解为字典），使得我们能更快速的去找到想要的数据。2.mysql引擎类型：InnoDB:1支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。MyISAM:1插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。数据库引擎的选择**MyISAM更适合读密集的表，而InnoDB**更适合写密集的的表。在数据库做主从分离的情况下，经常选择MyISAM作为主库的存储引擎。如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，这时选InnoDB是不错的。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM是最好的选择3.数据库事务：特性原子性要么都成功，要么都失败一致性事务结束后系统状态是一致的，（钱还是那么多钱）隔离性隔离级别级别解释缺点读未提交在其他事务还没提交的时候就去读取会产生脏读，可以看到别人还没提交的事务产生的结果读提交等待事务完成时再去读会产生虚读，即在别的事务开始前（别的事务进行了update操作），和别的事务提交后读取到的数据不一样重复读事务开始之后，就不许其他事务再去做更新操作了会产生幻读，其他事务执行insert的时候还是会导致在该事务前后读取的不一样（下单卖了一台电脑）序列化事务串行化顺序执行但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用持久性事务一旦提交后，对数据库中的数据改变是永久性的。4. SQL优化：where和group by所使用的字段上加上索引;避免使用select *,使用具体的字段代替;模糊查询时使用“左匹配原则”;尽量避免使用IN、NOT IN 等关键词，会导致数据库引擎放弃索引进行全表扫描;尽量避免使用OR,会导致数据库引擎放弃索引进行全表扫描,可以用union代替or；尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描,可以给字段添加默认值0，对0值进行判断;尽量避免在where条件中等号的左侧进行表达式、内联函数操作5.MySql常用优化方案：加索引是加快查询速度最有效的方案；数据量大的时候要采用分库分表；读写分离。网络知识1. TCP的三次握手​ tcp连接中客户端和服务端建立连接前需要互相确认联通性，会互发三次网络请求：服务端向服务端发送SYN(seq=j)包，进入SYN_SENT状态等待服务端确认服务端接收到客户端的SYN包之后确认客户端的SYN包，同时自己也发送一个SYN(seq=k)包至客户端，即SYN+ACK,服务端进入SYN_RECV状态客户端接收到服务端的SYN+ACK 向服务端发送确认包ACK(ack=k+1),此包发送完成后，服务端和客户端即完成tcp连接​PHP基础知识1.php垃圾回收机制：php7声明一个变量并赋值后，在底层C实现是一个zval结构体和zend_value到的联合体，1234567891011$a = "abc916"zval &#123; string "a" //变量的名字是a value zend_value //变量的值 type string //变量是字符串类型&#125;zend_value &#123; string "abc916" //值的内容 refcount 1 //引用计数 &#125;引用计数：被引用的内存块有一个计数器refcount，用于记录被变量引用的次数，在他的计数器为0时内存即被释放,但是对于变量的循环引用依然会导致内存泄露，例如：1234&lt;?php $a = array('hahah'); //此时array对象的引用次数为1，‘one’的引用次数为1 $a[] = &amp;$a; //此时array对象的引用次数为2，‘one’的引用次数为1 unset($a); //此时array对象的引用次数为1，‘one’的引用次数为1,由于变量指针被销毁，这时这个array就会无法访问导致内存泄漏产生垃圾的情况数组：a数组的某个成员使用&amp;引用a自己对象：对象的某个成员引用对象自己垃圾回收原理：1、以php的引用计数机制为基础（php5.3以前只有该机制）2、同时使用根缓冲区机制，当php发现有存在循环引用的zval时，就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量后，就会进行垃圾回收，以此解决循环引用导致的内存泄漏问题（php5.3开始引入该机制）2. 常用魔术方法：__call()调用一个类中不存在的方法的时候运行__toString()当一个类的实例对象；被当成一个字符串输出时调用__isset()当对不可访问的私有属性使用isset或empty时自动调用__invoke()调用函数的方式调用一个对象时的回应方法__autoload()尝试加载未定义的类并发方面1.响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。2.吞吐量：单位时间内处理的请求数量。3.QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。4.并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。算法题：01背包问题：动态规划12345678910111213141516171819def bag(n, c, w, v): """ 测试数据： n = 6 物品的数量， c = 10 书包能承受的重量， w = [2, 2, 3, 1, 5, 2] 每个物品的重量， v = [2, 3, 1, 5, 4, 3] 每个物品的价值 """ # 置零，表示初始状态 value = [[0 for j in range(c + 1)] for i in range(n + 1)] for i in range(1, n + 1): for j in range(1, c + 1): value[i][j] = value[i - 1][j] # 背包总容量够放当前物体，遍历前一个状态考虑是否置换 if j &gt;= w[i - 1] and value[i][j] &lt; value[i - 1][j - w[i - 1]] + v[i - 1]: value[i][j] = value[i - 1][j - w[i - 1]] + v[i - 1] for x in value: print(x) return value最长回文子串：动态规划123456789101112131415161718class Solution: def longestPalindrome(self, s: str) -&gt; str: size = len(s) if size &lt;= 1: return s dp = [[False for _ in range(size)] for _ in range(size)] longest_l = 1 res = s[0] for r in range(1, size): for l in range(r): if s[l] == s[r] and (r - l &lt;= 2 or dp[l + 1][r - 1]): dp[l][r] = True cur_len = r - l + 1 if cur_len &gt; longest_l: longest_l = cur_len res = s[l:r + 1] return res基于快速排序输入一组逗号分割的数，将这组数组合成为一个最小的数。123456如输入：123,22,32输出：1232232输入：210,21,11,12输出：111221021123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpfunction mySort($a,$b)&#123; $f_a = (int)substr( $a, 0, 1 ); $f_b = (int)substr( $b, 0, 1 ); if($f_a==$f_b)&#123; $resa = (int)($a.''.$b); $resb = (int)($b.''.$a); if($resa&gt;$resb)&#123; return 1; &#125;else&#123; return 0; &#125; &#125; if($f_a&gt;$f_b)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;function quicksort($left,$right,&amp;$arr)&#123; if($left&gt;$right)&#123; return; &#125; $a = $arr[$left]; $i = $left; $j = $right; while ((int)$i != (int)$j)&#123; while(mySort($arr[$j],$a) &amp;&amp; $i &lt; $j)&#123; $j --; &#125; while ((!mySort($arr[$i],$a)) &amp;&amp; $i&lt;$j) &#123; $i ++; &#125; if($i&lt;$j)&#123; $t = $arr[$i]; $arr[$i] = $arr[$j]; $arr[$j] = $t; &#125; &#125; $arr[$left] = $arr[$i]; $arr[$i] = $a; #更換基準數 quicksort($left,$i-1,$arr); quicksort($i+1,$right,$arr);&#125;$arr = array('125','12','3','31');quicksort(0,3,$arr);print_r($arr);]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现动态公网IP下掌握最新IP]]></title>
    <url>%2Fposts%2Ff299d5cf.html</url>
    <content type="text"><![CDATA[上篇博客写到将自己的电脑设置为DMZ主机直接暴露到外网，将自己的主机当作服务器使用，使用过程中发现电信的动态IP经常会更换，而且更换规律捉摸不透，经常因为IP变动导致无法连接到电脑解决方案遇到这个问题首先被想到的肯定是DDNS服务(动态域名解析)，这的确是个好办法，但是我注册好一个花生壳账号之后，发现我的垃圾路由器并不支持花生壳的DDNS，并且我也不想在我的电脑上安装他的客户端（并且我注册好花生壳后不到三分钟，就有花生壳的人打电话来说让我用付费版，说速度快，让人很反感）到这里，DDNS这条路我是走不通了，于是我又想出来一个比较简单粗暴地方法，即：在我的电脑上写一个定时任务，获取到当时的公网IP然后再想办法让我能看到这个更新的IP,而coding或者GitHub的pages服务则是可以让我看到我的IP的一个绝佳的方式，可以将获取到的IP写在HTML文件里,再使用git将其推送到远程仓库展示出来,于是写下如下Python程序：123456789101112131415#!/usr/bin/python# -*- coding:utf8 -*-import requests,osimport reurl = requests.get("http://txt.go.sohu.com/ip/soip")#获取当前公网IPtext = url.textip = re.findall(r'\d+.\d+.\d+.\d+',text) #截取出IPos.chdir("E://ip_update//ip_table") #工作目录调整到显示ip的git仓库下r = open(r'.\ip.html','w+')old_ip = r.read()old_ip.replace(" ", "")if old_ip != ip[0]: #新老IP若不一致则写文件，并且更新 r.write(ip[0]) r.close() os.system("git add . &amp;&amp; git commit -m 'update' &amp;&amp; git push origin master")并且在coding上新开了一个项目,只有一个index.html，用于显示更新IP。接下来的问题就是让这个python脚本定时运行，这里可以使用windows的任务计划程序完成，过程不再赘述。]]></content>
      <categories>
        <category>随意折腾</category>
      </categories>
      <tags>
        <tag>动态公网IP</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破解天翼网关使用端口映射]]></title>
    <url>%2Fposts%2F1566dc66.html</url>
    <content type="text"><![CDATA[Teamviewer的烦恼平时在外面经常需要远程连接到自己的电脑远程做一些操作，之前一直使用teamviewer，近期不知道为什么我被teamviewer检测为商用了每次只有5分钟的市场非常让人恼火。看了一下官网的价格：这个价格。。。对于习惯了“白嫖”的我们来说就可以直接劝退了。破解光猫超级管理员账号于是乎我想起了找个替代方案，windows的远程桌面似乎就是个不错的选择,但是远程桌面必须是有公网IP才能使用，于是我查询了一下，我的出租房内用的电信宽带居然是独立的静态IP，也就是说只要猫或者路由器支持，就可以使用它的端口映射功能将我的电脑的端口映射到公网上，那样我就能随时随地的远程桌面了，看了一下我电脑连接的猫是个中兴的产品，进入http://192.168.1.1,顺利进入猫的管理登陆页面:试了一下常用的admin账号会用的密码，无果，于是乎搜索一番找到了一个破解中心猫的方法：进入http://192.168.1.1/manager_dev_config_t.gch，如图选择“导出配置”即可导出一个config.bin的猫的配置文件打开http://www.upantool.com/qita/2014/4848.html，下载一个叫做offzip的工具来解压这个配置文件，下载完成后，将解压后的文件和comfig.bin放在一起，打开命令行窗口,输入offzip -a ./config.bin ./ 0得到如下结果，文件夹中会出现一堆文件用文本编辑器依次打开各个文件，查找关键字telecomadmin就可以找到如图所示的内容，password即是猫的超级管理员密码。尝试登陆，成功登陆超级管理员页面。设置主机为DMZ主机或者虚拟服务器DMZ主机指的是位于网关之外的主机，它的所有端口面向公网，这就相当于身为DMZ主机的内网主机拥有了一个公网的IP；虚拟服务器路由器中可以设置虚拟服务器的功能，值得是把某一内网主机的某些端口映射公网上。这台中兴的猫两个功能都支持，不多说了，中兴牛逼;设置位置如下：测试将猫重启之后，在外网尝试远程连接之后，再见吧,Teamviewer!!!]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>远程桌面</tag>
        <tag>天翼网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python实现UDP内网穿透]]></title>
    <url>%2Fposts%2F4e37bb03.html</url>
    <content type="text"><![CDATA[网络编程中，常常使用udp进行数据传输，由于iPv4地址的紧缺，所以路由器上出现了NAT这种折中方案，使得内网中的主机在外网是无法发现的，内网的数据包是由NAT进行端口映射，在发送到公网上。这样就使内网的主机的ip端口是不确定的，公网中的数据包便无法发送进来，尤其在p2p网络中影响较大内网NAT的链接方式由于内网的主机有了一层NAT，主机A和主机B是无法直接的互相发送数据包的，因为他们互相无法知道对方的映射地址内网穿透思路要实现内网穿透，首先肯定是要有一个有公网IP的服务器作为内网主机的引导，使用python.socket完成数据通信，服务器端主要完成以下任务：保存所有连入的主机的IP和端口号；监测心跳信息判断连入的主机是否存活，刷新存活的主机列表；向连入的内网主机发送现有的主机列表。内网的主机需要完成以下任务：连入服务器，向其发送数据包；接收服务器端传回的主机列表，更新主机列表；由于NAT映射存留session时间较短，需间隔几秒向向服务器发送心条信息使用到的数据包：PING： 向指定的主机发送的第一个数据包PONG： 收到其他主机发来的PING数据包返回一个PONG数据包FIND_NODE: 向引导服务器请求获取现有的主机列表HEART: 心跳数据包，向引导服务器证明主机尚存活RESPONSE_NODE:引导服务器向内网主机传回主机列表服务端实现服务端需要两个线程：判断收到的数据包类型，并进行相应操作；定时维护现有的主机列表。实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# -*- coding: utf-8 -*-import socket,time,threading,jsondef headers(data): #解析数据包 header_content = data.split('\r\n\r\n', 1)[0].split('\r\n')[0:] result = &#123;&#125; for line in header_content: k, v = line.split(':',1) result[k.strip(" ")] = v.strip(" ") return resultdef recv_ping(socket,addr): #接收客户端的ping if addr not in nodes: nodes.append(addr) #添加时间戳 alive.append([addr,time.time()]) print("add_new node") send_pong(socket,addr) def send_pong(socket,addr): msg = "Content-Type:PONG\r\n" msg += "ip:"+addr[0]+"\r\n" msg += "port:"+str(addr[1])+"\r\n" msg += "msg:I`m fine!\r\n\r\n" #消息 socket.sendto(msg.encode("utf-8"),addr) #回复Pong print "回应ping" print adddef nodes_back(socket,addr): #服务端返回节点列表 response = "Content-Type:RESPONSE_NODE\r\n" str = json.dumps(nodes) response += "nodes:"+str+"\r\n\r\n" print("返回节点列表") socket.sendto(response,addr)def append_node(addr): if addr not in nodes: send_pong(socket.socket(socket.AF_INET,socket.SOCK_DGRAM),addr) for n in nodes: if n[0] == addr[0]: nodes.pop(nodes.index(n)) #清除旧的addr nodes.append(addr) alive.append([addr,time.time()]) print("add_new node") else: for a in alive: if a[0] == addr: a[1] = time.time() #更新最后链接时间 break;def recv(receive,header,addr): header = headers(header) if header["Content-Type"] == "PING": #收到PING数据 recv_ping(receive,addr) if header["Content-Type"] == "FIND_NODE": nodes_back(receive,addr) if header["Content-Type"] == "HEART": print "heart from" append_node(addr) print addr passdef refrush_nodes(socket): while True: if len(nodes) &gt; 0: print "开始刷新列表" for a in alive: now = time.time() if now - a[1] &gt; 5.0: print "去掉"+a[0][0] nodes.pop(nodes.index(a[0])) #去掉超过5s未连接的客户机 alive.pop(alive.index(a)) for n in nodes: print "刷新列表" nodes_back(socket,n) time.sleep(5)nodes = []alive = []if __name__ == "__main__": addr = ('0.0.0.0',20006) receive = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) receive.bind(addr) print 'Waiting for connection...' t1 = threading.Thread(target=refrush_nodes, args=(receive,)) t1.start() while True: # 接受一个新连接: header,address = receive.recvfrom(2048) # 创建新线程来处理TCP连接: t = threading.Thread(target=recv, args=(receive,header,address)) t.start()其中，使用两个全局变量：nodes和alive分别存储他们的ip、端口信息和最后一次发送心跳HEART数据包的时间，这样就能帅选出已经掉线的主机信息并剔除。服务端操作流程如下所示：内网主机端实现内网主机端需要两个线程：判断收到的数据包类型，并进行相应操作；定时向引导服务器发送HEART心跳数据包。实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# -*- coding: utf-8 -*-import socket,time,threading,jsondef headers(self,data): #解析数据包 header_content = data.split('\r\n\r\n', 1)[0].split('\r\n')[0:] result = &#123;&#125; for line in header_content: k, v = line.split(':',1) result[k.strip(" ")] = v.strip(" ") return resultdef send_ping(socket,addr,msg=""): #send ping #socket.sendto("ping".encode('UTF_8'),addr) request = "Content-Type:PING\r\n" request += "msg:Are you OK!"+msg+"\r\n\r\n" #消息 socket.sendto(request.encode("utf-8"),addr) print("send_ping") print ("发送ping到"+addr[0])def recv_ping(socket,addr): #接收客户端的ping global nodes while True: msg,addr = socket.recvfrom(2048) h = headers(msg) if(addr not in nodes): nodes.append(addr) print("add_new node") msg = "Content-Type:PONG\r\n" msg += "Msg:hello\r\n\r\n" socket.sendto(msg,addr)def get_nodes(socket,addr): #ask to server request = "Content-Type:FIND_NODE\r\n" request += "msg:Are you OK!\r\n\r\n" #消息 print("向请求邻居") print (request) socket.sendto(request.encode("utf-8"),addr)def headers(data): #解析数据包 print(data) data = data.decode("utf-8") header_content = data.split('\r\n\r\n', 1)[0].split('\r\n')[0:] result = &#123;&#125; for line in header_content: k, v = line.split(':',1) result[k.strip(" ")] = v.strip(" ") return resultdef nodes_back(socket,addr): #服务端返回节点列表 response = "Content-Type:RESPONSE_NODE\r\n" socket.sendto()def recv(receive,server_addr): while True: global nodes data,addr = receive.recvfrom(2048) #收到服务器的回应 header = headers(data) if header["Content-Type"] == "PONG" and addr == server_addr: #收到回应的话每隔几秒发送心跳信息 t2 = threading.Thread(target=heart, args=(receive,addr)) t2.start() if header["Content-Type"] == "RESPONSE_NODE": print("收到列表") node_list = json.loads(header["nodes"]) global nodes nodes = [] for value in node_list: t = tuple(value) if value not in nodes and t != myaddr: nodes.append(t) if header["Content-Type"] == "PONG" and addr != server_addr: msg = "Content-Type:NAT\r\n" msg += "msg:success\r\n\r\n" receive.sendto(msg.encode("utf-8"),addr) if header["Content-Type"] == "PING": msg = "Content-Type:PONG\r\n" msg += "msg:success\r\n\r\n" receive.sendto(msg.encode("utf-8"),addr)def heart(socket,addr): #发送心跳 msg = "Content-Type:HEART\r\n" msg += "msg:i'm alive!\r\n\r\n" while True: socket.sendto(msg.encode("utf-8"),addr) time.sleep(3)nodes = []myaddr = ()if __name__ == "__main__": addr = ('47.101.137.17',20006) receive = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) send_ping(receive, addr) #say hello与服务器建立连接 t = threading.Thread(target=recv, args=(receive,addr)) t.start() get_nodes(receive, addr) #获取节点列表 while True: print (nodes) if len(nodes)&gt;0: for i in range(1,len(nodes)): if nodes[i] != myaddr: send_ping(receive,nodes[i],nodes[i][0]) time.sleep(3)其中使用nodes全局变量来存储现有的主机列表内网机端的执行流程如下图所示：结论这么看起来NAT的穿透并不是很复杂，后期NAT穿透可以用于P2P网络的搭建，使得内网也可是使用P2P网络。]]></content>
      <categories>
        <category>Python</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>内网穿透</tag>
        <tag>p2p</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加背景轮播图]]></title>
    <url>%2Fposts%2F50d69843.html</url>
    <content type="text"><![CDATA[原生的next主题的背景是纯白的看起来十分的单调，这里使用jquery-backstretch插件可以设置页面的背景图片，来定制化自己的博客。使用插件jquery-backstretchjquery-backstretch是一个简单的可设置动态背景图的插件，可直接使用官网提供的CDN也可下载下来使用。使用方法引入插件cdn创建一个themes\next\layout_custom\custom-foot.swig文件，用于包含一些js文件，在文件中添加：1234&lt;!-- 图片轮播js文件cdn --&gt;&lt;script src="https://cdn.bootcss.com/jquery-backstretch/2.0.4/jquery.backstretch.min.js"&gt;&lt;/script&gt;&lt;!-- 自定义的js文件 --&gt;&lt;script type="text/javascript" src="/js/src/custom.js"&gt;&lt;/script&gt;custom.js中可添加我们自定义的一些js方法，为了正常使用插件，引入的插件需放在custom.js之前，因为在custom.js中需要使用到插件中的方法，这样可能会出现报错。custom-foot.swig保存之后打开themes\next\layout\index.swig,这个文件是整个页面的框架文件，在&lt;/body&gt;标签前插入：1&#123;% include '_custom/custom-foot.swig' %&#125;这样cdn就引入了页面了，以后需要使用的插件也都可以在custom-foot.swig中引入。调用插件的backstretch方法生成轮播图找一些想要的图片，放到source/images/background文件夹中，打开themes\next\source\js\src\custom.js文件，添加如下代码：12345678 /* 轮播背景图片 */$(function () &#123; $.backstretch([ "/images/background/bg1.jpg", "/images/background/bg2.jpg", "/images/background/bg3.jpg" ], &#123; duration: 20000, fade: 1500 &#125;); &#125;);其中参数中的duration是轮播图间隔时间，duration是切换过渡效果的时间。优化显示效果如果背景图太鲜艳，由于文章内容都是白色的容易造成背景图喧宾夺主的感觉，同时由于博客内容的遮挡，图片也只能看到边角，所以这里可以将背景和页面设置为部分透明，只需打开themes\next\source\css\_custom\custom.styl,这个文件是用于一些自定义的css样式,可直接在此修改一些原有标签的样式，在文件中添加：12345678/* 背景图透明度 */.backstretch &#123; opacity: .85;&#125;/* 页面透明度 */.content-wrap, .sidebar &#123; opacity: .9 !important;&#125;这里其实可以在博客中找到指定的空间的class标签,直接在custom.styl重新定义样式就可以把博客自定义成想要的样子啦。参考文章感谢雨临Lewis]]></content>
      <categories>
        <category>hexo博客</category>
        <category>next个性化</category>
      </categories>
      <tags>
        <tag>Next主题</tag>
        <tag>轮播图</tag>
        <tag>个性化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java/php/Python/Golang性能测试]]></title>
    <url>%2Fposts%2F6573d2e3.html</url>
    <content type="text"><![CDATA[编程语言性能测试各种编程语言之间各自皆有长处，也有短处，速度快的语言必然逃不了强类型、语法复杂等特点，写起来优雅的语言必然面临着速度缓慢的问题。今天我就来测试一下我所熟悉的几种语言的速度究竟如何，这里分别使用JAVA、PHP、Python和Golang四种编程语言进行测试，我写了一个涉及算数操作、字符串、和数据类型转换操作的函数，让他循环执行一百万次来测试程序需要执行多久，下面请看代码：1.java:123456789101112131415161718192021222324252627public class Test&#123; public static void main(String[] args) &#123; long t1 = System.currentTimeMillis(); for(int i=0; i&lt;10000000; i++)&#123; aaa((float)i); &#125; long t2 = System.currentTimeMillis(); System.out.println("java time" + String.valueOf(t2 - t1) + "ms"); &#125; static void aaa(float i)&#123; float a = i + 1; float b = 2.3f; String s = "abcdefkkbghisdfdfdsfds"; if(a &gt; b)&#123; ++a; &#125;else&#123; b = b + 1; &#125; if(a == b)&#123; b = b + 1; &#125; float c = (float) (a * b + a / b - Math.pow(a, 2)); String d = s.substring(0, s.indexOf("kkb")) + String.valueOf(c); &#125;&#125;2.PHP1234567891011121314151617181920212223&lt;?phpfunction aaa($i)&#123; $a = $i + 1; $b = 2.3; $s = "abcdefkkbghisdfdfdsfds"; if($a &gt; $b)&#123; ++$a; &#125;else&#123; $b = $b + 1; &#125; if($a == $b)&#123; $b = $b + 1; &#125; $c = $a * $b + $a / $b - pow($a, 2); $d = substr($s, 0, strpos($s, 'kkb')) . $c;&#125;$t1 = microtime(true);for($i=0; $i&lt;10000000; $i++)&#123; aaa($i);&#125;$t2 = microtime(true);echo 'php time:' . ($t2 - $t1)*1000 . "ms\n";?&gt;3.python:123456789101112131415161718import math,timedef aaa(i): a = i + 1 b = 2.3 s = "abcdefkkbghisdfdfdsfds" if a &gt; b: a = a + 1 else: b = b + 1 if a == b: b = b + 1 c = a * b + a / b - math.pow(a , 2) d = s[0:s.index("kkb")]+str(c)t1 = time.time()for i in range(10000000): aaa(i)t2 = time.time()print("python time :"+str((t2-t1)*1000)+"ms\n")4.Golang1234567891011121314151617181920212223242526272829303132package mainimport ( "time" "math" "strings" "strconv" "fmt") func main() &#123; var t1 int32 = int32(time.Now().UnixNano()/ 1e6) for a := 0; a &lt; 10000000; a++ &#123; aaa(a) &#125; var t2 int32 = int32(time.Now().UnixNano()/ 1e6) fmt.Printf("Go time: %d ms\n", (t2-t1))&#125;func aaa(i int) string&#123; var a = float64(i) + 1 var b float64 = 2.3 var s string= "abcdefkkbghisdfdfdsfds" if a &gt; b&#123; a = a + 1 &#125;else&#123; b = b + 1 &#125; if a == b&#123; b = b + 1 &#125; var c float64 = a * b + a / b - math.Pow(a, 2) var d string = s[0:strings.Index(s, "kkb")] return strconv.FormatFloat(c, 'E', -1, 32)+d&#125;测试环境windows 7 ,inter i3, 4GB内存python3.6 , Golang 1.11.2 , PHP7.2.1 ,JDK1.8测试结果如下：由测试结果可以看出，java毫无悬念的最快，让我没想到的是,我用的php7.2整整比java慢了六七倍，GO语言的确是很强，值得学习，python不出所料的慢。最慢的php和python明显写起来要更加的简洁一点，动态语言带来的好处就是不用过多的去在意一个数据的类型是什么。根据结果得出结论：速度和性能方面：编译型语言&gt;解释型语言，强类型语言&gt;弱类型语言我个人还是蛮喜欢Golang和python的……_,虽然我现在是php程序员]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之配置]]></title>
    <url>%2Fposts%2Ff8ae19a9.html</url>
    <content type="text"><![CDATA[pom.xml文件定义各种项目中使用到的版本依赖，导入大部分依赖不需要写版本号1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;spring-boot-starter:场景启动器，导入web模块的所需的组件SpringBoot 将所依赖的功能抽取出来做成了一个个的starter(启动器),项目中引入这些starter,即可自动导入相应依赖（启动器）Application主程序1234567@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;1.@SpringBootApplication注解：说明当前类为主配置类，通过main方法启动SpringBoot应用，点进注解可见如下组合注解123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@SpringBootConfiguration:SpringBoot的配置类，表示这是一个配置类@EnableAutoConfiguration:开启自动配置功能 ：123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)​ @AutoConfigurationPackage:将主配置类的所在包,及以下所有子包的所有组件扫描到spring容器中SpringBoot配置可用XXX.yml文件作为配置文件，用于配置非默认配置值的项目写法1.基本语法：key: (空格)value – 键值对 （大小写敏感）123server: port: 8088 path: /hello2.value写法字面量​ 可使用数字、字符串、布尔​ 字符串默认不用加上双引号或者单引号，双引号不转义特殊字符对象、map:key: value方式123human: name: zhangsan age: 20行内写法：1human: &#123;name: zhangsan,age: 20&#125;数组（List,Set）:12345citys: - shanghai- guangzhou- shengzheng- beijing行内写法：1citys: [shanghai,guangzhou,shengzheng,beijing]配置对应Bean@ConfigurationProperties和@Value注解@ConfigurationProperties(prefix=&quot;human&quot;) 将属性全部注入类的成员变量中（默认从全局配置文件中取值）@Value(&quot;{$huamn.name}&quot;) 一个个属性的注入（一般在业务逻辑中需要使用某项配置值的时候使用，例如某些需要写死的数据临时需要使用）@PropertySource和@ImportResource注解@PropertySource(value = {classpath:person.yml})😦指定配置文件加载）@ImportResource(localtion={&quot;classpath:XXX.xml&quot;}):导入Spring配置文件，让配置文件生效（兼容xml配置文件）SpringBoot推荐给容器添加组件的方式：（使用全注解的方式）配置类加上@Configuration注解使用@Bean添加组件12345678@Configurationpublic calss MyAppConfig()&#123; //将方法返回值添加到容器中，组件默认ID就是方法名 @bean public Myservice myService()&#123; return ; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之HelloWorld]]></title>
    <url>%2Fposts%2F9580d45f.html</url>
    <content type="text"><![CDATA[一.创建SpringBoot项目使用IDEA创建项目二.SpringBoot使用创建项目主程序DemoApplication 类，@SpringBootApplication注解表示这是一个入口主程序12345678910@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)public class DemoApplication &#123; public static void main(String[] args) &#123; // 启动运行当前主程序 SpringApplication.run(DemoApplication.class, args); &#125;&#125;创建IndexController类:在当前包下新建一个Controller类 IndexController类1234567@RestController //表示这是一个控制器public class IndexController &#123; @RequestMapping("/hello") //路由 public String hello()&#123; return "Hello World"; &#125;&#125;运行主程序：SpringBoot内建了tomcat直接可以运行三.部署：将 应用打包为一个jar包，在pom.xml中加入一下配置将spring-boot-maven-plugin添加到项目中12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;保存并运行1mvn package打包完成后可在target目录中看到对应的jar包使用java -jar target/demo-0.0.1-SNAPSHOT.jar命令即可运行jar包]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python实现p2p聊天]]></title>
    <url>%2Fposts%2F97adfa45.html</url>
    <content type="text"><![CDATA[P2P是&quot;peer-to-peer&quot;的简称,中文名点对点传输技术,纯点对点网络没有客户端或服务器的概念，只有平等的同级节点，同时对网络上的其它节点充当客户端和服务器。一、需求1.使用python实现P2P聊天室，主要依靠socket来实现通信；2.由于现在我们基本都是使用的局域网ip，所以正真的没有服务端中转通信是不现实的，所以只能采用一个服务端转发来实现点对点通信；3.实现私聊和广播两种聊天功能。二、服务端实现1.socket的初始化：分为导入包、初始化、绑定端口和监听端口几个操作1234import socket //导入socket包s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) //初始化sockets.bind(('0.0.0.0',6666)) //绑定端口s.listen(10) //监听端口2.聊天队列的处理：这里需要使用多线程来处理每一个socket连接，为每个连接的用户提供消息转发服务12345678while True: //等待连接 # 接受一个新连接: sock, addr = s.accept() person.append(&#123;'addr':addr,'sock':sock,'name':''&#125;) # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start()新连接的信息存储在一个list中，首次连接的时候，询问客户机的名称连同socket对象一起存储到list中。3.聊天消息转发的实现：根据用户选择的聊天模式转发给对应的对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input '%-1' to quit,input '%-2' to quit talk." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8')) mode = 0 ##代表当前聊天模式 0：功能选择，1：P2P对话模式，2：广播模式 target = "" while True: data = sock.recv(2048).decode('utf-8') if data[0] == '%': c = data[1:] if c == "public": //选择广播聊天模式 sock.send(b'sys:Ok,you can talk with all of people now.') mode = 2 elif c == "refresh": //刷新聊天列表 online_list = "******************online_list********************\n" for i in range(0, len(person)): online_list += "%d : name:%s ip:%s \n" % (i,person[i]['name'],person[i]['addr'][0]) online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input %-1 to quit." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8')) elif c == "-1": //退出当前聊天模式（广播、私聊） sock.send("bye!".encode('utf-8')) sock.close() mode = 0; break elif c == "-2": //退出聊天 sock.send("sys:already quit talk.".encode('utf-8')) mode = 0 else: c1 = int(c) target = person[c1] mode = 1 else: if mode == 1: //私聊模式 str = "%s(%s):%s\n time:%s" % (name,addr,data,time.time()) target_sock = target['sock'] target_sock.send(str.encode('utf-8')) elif mode == 2: //广播模式 str = "[Radio]%s(%s):%s\n time:%s" % (name,addr,data,time.time()) for i in range(0, len(person)): //向所有节点转发 target_sock = person[i]['sock'] target_sock.send(str.encode('utf-8')) elif mode == 0: online_list = "******************online_list********************\n" for i in range(0, len(person)): online_list += "%d : name:%s ip:%s \n" % (i,person[i]['name'],person[i]['addr'][0]) online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input %-1 to quit." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8'))三、客户端实现客户端只需要一个接收线程和一个发送线程即可12345678910111213141516171819202122232425def recv_message(sock): while True: data = sock.recv(2048).decode('utf-8') //接收消息 print(data) time.sleep(5)def send_message(sock): while True: data = input('speak:') //发送消息 sock.send(data.encode('utf-8')) time.sleep(5) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect(("xxx.xxx.xxx.xxx",6666)) //连接服务端 recv1 = threading.Thread(target=recv_message, args=(s,))send1 = threading.Thread(target=send_message, args=(s,))recv1.start()time.sleep(2)send1.start()recv1.join()send1.join()四、具体代码server.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#!/usr/bin/env python# encoding=utf-8import socketimport threading,timedef tcplink(sock, addr): name="" print('Accept new connection from %s:%s...' % addr) for i in range(0, len(person)): print(person[i]) if addr == person[i]['addr']: if person[i]['name'] == "": print("send hello") sock.send(b'sys:What is your name?') data = sock.recv(2048).decode('utf-8') person[i]['name'] = data name = data break online_list = "******************online_list********************\n" for i in range(0, len(person)): online_list += "%d : name:%s ip:%s \n" % (i,person[i]['name'],person[i]['addr'][0]) online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input '%-1' to quit,input '%-2' to quit talk." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8')) mode = 0 ##代表当前聊天模式 0：功能选择，1：P2P对话模式，2：广播模式 target = "" while True: data = sock.recv(2048).decode('utf-8') if data[0] == '%': c = data[1:] if c == "public": sock.send(b'sys:Ok,you can talk with all of people now.') mode = 2 elif c == "refresh": online_list = "******************online_list********************\n" for i in range(0, len(person)): online_list += "%d : name:%s ip:%s \n" % (i,person[i]['name'],person[i]['addr'][0]) online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input %-1 to quit." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8')) elif c == "-1": sock.send("bye!".encode('utf-8')) sock.close() mode = 0; break elif c == "-2": sock.send("sys:already quit talk.".encode('utf-8')) mode = 0 else: c1 = int(c) target = person[c1] mode = 1 else: if mode == 1: str = "%s(%s):%s\n time:%s" % (name,addr,data,time.time()) target_sock = target['sock'] target_sock.send(str.encode('utf-8')) elif mode == 2: str = "[Radio]%s(%s):%s\n time:%s" % (name,addr,data,time.time()) for i in range(0, len(person)): target_sock = person[i]['sock'] target_sock.send(str.encode('utf-8')) elif mode == 0: online_list = "******************online_list********************\n" for i in range(0, len(person)): online_list += "%d : name:%s ip:%s \n" % (i,person[i]['name'],person[i]['addr'][0]) online_list += "\n\n\n input the %+number(%1) to choose somebody to talk \n input '%public' to talk with all of people,\n input '%refresh' to reload online_list \n input %-1 to quit." online_list += "*************************************************\n\n\n" sock.send(online_list.encode('utf-8')) print(person)s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)person = [] #存储来的人s.bind(('0.0.0.0',6666))s.listen(10)print('Waiting for connection...')while True: # 接受一个新连接: sock, addr = s.accept() person.append(&#123;'addr':addr,'sock':sock,'name':''&#125;) # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start()client.py1234567891011121314151617181920212223242526272829#!/usr/bin/env python# encoding=utf-8import socketimport threading,timefrom multiprocessing import Processimport osdef recv_message(sock): while True: data = sock.recv(2048).decode('utf-8') print(data) time.sleep(5)def send_message(sock): while True: data = input('speak:') sock.send(data.encode('utf-8')) time.sleep(5)s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect(("xxx.xxx.xxx.xxx",6666)) recv1 = threading.Thread(target=recv_message, args=(s,))send1 = threading.Thread(target=send_message, args=(s,))recv1.start()time.sleep(2)send1.start()recv1.join()send1.join()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>p2p,python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python和gitlab的webhook完成git的自动部署]]></title>
    <url>%2Fposts%2F8d538eb8.html</url>
    <content type="text"><![CDATA[大部分公司的代码版本控制都是采用git,基本都是采用自己搭建一个gitlab的方式来协同开发，一般代码仓库和项目不会放在用一个目录中，程序员写好代码提交之后就不方便直接部署到服务器上.gitlab和github等一众平台都提供了一个功能叫webhook,可以配置一个地址和口令，每次有push请求或者其他请求时，gitlab就会向用户所提供的地址放一个GET请求的数据包，这样就可以在项目中写一个webhook的接口来处理push请求，我认为在项目上直接写一个这样的接口不太好，可以采用socket解析数据包的内容来完成代码如下：1234567891011121314151617181920212223242526272829import socket,osimport json,timefrom config import *from urllib import *def headers(data): #解析数据包 header_content = data.split('\r\n\r\n', 1)[0].split('\r\n')[1:] result = &#123;&#125; for line in header_content: k, v = line.split(': ') result[quote(k)] = quote(v) return results = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #建立sockets.bind(('0.0.0.0',10987)) #绑定socket端口s.listen(10)print "waiting connect"while True: sock, addr = s.accept() res = sock.recv(4096).decode('utf-8') header = headers(res) if "X-Gitlab-Token" in header.keys(): if header["X-Gitlab-Token"] == "istillloveyou": if header["X-Gitlab-Event"] == "Push%20Hook": os.system("cd %s &amp;&amp; git pull origin master" % config["project_path"]) print time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) print "**************************************************************"]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python批量修改文件的关键字]]></title>
    <url>%2Fposts%2Fbd6f75fc.html</url>
    <content type="text"><![CDATA[人生苦短，我用pythonpython真的是一个非常实用且轻便的语言，今天在公司里前端写了一堆页面之后,经理看完效果之后突然来了一句：“这个页面里面所有的‘见习’要改成‘实习’哎” 前端听完露出了一万头草拟马奔驰而过的表情，毕竟一堆页面在那。我在旁边听完之后心想，这可得我来露一手了。于是乎，我捧出我心爱的Python，洋洋洒洒写了一个脚本,其实是个特别简单的程序，记得大一时用C语言就应该写过类似的程序，只是现在C语言可能早已忘到天边了，主要就是递归遍历文件夹中的所有文件，将每个文件中的指定关键字切换。递归遍历文件夹：使用Python的os.listdir()方法列出当前文件夹下的所有元素，若是文件夹继续遍历替换文件关键字：open()打开文件使用read()函数读取内容注意文件的编码,这里要使用decode()转换成utf8格式,保证编码不会出问题。以下为全部代码:12345678910111213141516171819import osdef getAllfileAndDirPath(sourcePath): if not os.path.exists(sourcePath): return listName = os.listdir(sourcePath) for name in listName: absPath = os.path.join(sourcePath,name) if os.path.isfile(absPath): if absPath.find('.') != -1 and absPath[absPath.find('.') :] == ".php": with open(absPath,'rb+') as f: t = f.read().decode('utf8') t = t.replace("见习",,"实习") f.seek(0,0) f.write(t.encode('utf8')) print("修改%s完成" % absPath) if os.path.isdir(absPath): getAllfileAndDirPath(absPath)getAllfileAndDirPath(r'test')]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客之Hello World]]></title>
    <url>%2Fposts%2Fcd0da4fc.html</url>
    <content type="text"><![CDATA[1.Hello World!如果你想写博客玩儿的话，那么有两种方式：使用CSDN等博客网站和自己搭建一个博客，搭建博客的话不用买服务器那是最棒的2.搭建博客博客对于一个高逼格程序员有以下作用：整理知识，学习笔记发布日记，杂文，所见所想完善自己的知识体系方便回顾自己的学习历程创建github账号总之养成写博客的习惯对于自身的学习还是很有用处，利用github+Hexo搭建博客首先当然是要有一个github账号啦，这里不多说，直接前往Github注册一个账号，然后下载git客户端巴拉巴拉巴拉，网上这类教程一堆，我也懒得去抄了、、、安装node.js环境git搞定之后接下来就是配置hexo博客了，hexo博客是基于node.js的一款优秀的开源博客系统，首先安装node.js环境，前往node.js官网http://nodejs.cn/下载对应的系统的安装包，安装完成之后在命令行键入1node -v有出现如下的node.js版本信息即为安装成功安装hexo博客接下来就是要安装hexo了，hexo可以使用node.js的npm包管理器来安装，这里建议先将npm的源换为国内源，这样就不会下载速度巨慢了。国内淘宝源还是不错的，在命令行窗口中输入如下命令：1234npm config set registry https://registry.npm.taobao.org// 配置后可通过下面方式来验证是否成功npm config get registry// 或npm info express然后键入1npm install -g hexo安装完成之后键入 hexo -v 出现版本信息即为安装成功。下面来建立博客，进入想要新建博客的位置，在命令行进行如下操作：1hexo init这时该目录下就会生成一些博客的源文件，如图所示：至此博客建立就基本完成了，下面就是将博客编译运行起来并且发布到github的pages仓库中去。发布博客首先在github上建立Repository，名称必须与你用户名对应的仓库，仓库名为【your_user_name.github.io】然后，进入刚刚新建的博客目录中，找到博客根目录下的_config.yml文件，翻倒文件最下面 ，改成：123456deploy: type: git repo: https://github.com/leopardpan/yourname.github.io.git #你的github仓库的地址 branch: master #分支名然后执行命令：1npm install hexo-deployer-git --save然后继续执行命令12hexo g //编译生成静态博客页面hexo d //发布到github仓库中也可以直接执行1hexo d -g到此为止博客搭建就算完成啦。但是这样博客还是蛮丑的，可以采用第三方的主题来美化博客，我使用的是NexT主题，可以参照NexT官网文档来进一步配置http://theme-next.iissnan.com/。]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>helloworld,搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试博客]]></title>
    <url>%2Fposts%2Fd9407122.html</url>
    <content type="text"><![CDATA[这是一个测试文章第一篇测试文章，哈哈哈！]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssr使用说明]]></title>
    <url>%2Fposts%2F297bb6a6.html</url>
    <content type="text"><![CDATA[&quot;在群体之中，绝对不存在理性的人。……群体能够消灭个人的独立意识，独立的思考能力。事实上，早在他们的独立意识丧失之前，他们的思想与感情就已被群体所同化。”​ --乌合之众安装Shadowsocks下载shadowsocks​ windows可戳此下载下载,其他平台请自行百度或者GitHub上去查找解压压缩文件即可运行如图所示软件使用本站的shadowsocks服务器资源注意: 本站资源为全网搜集的免费资源,不保证可用性,不保证速度且不保证隐私安全!!点击[获取连接信息]按钮即可获取服务器信息,按对应内容填入shadowsocks软件内即可若出现无法获取的情况,请检查当前访问的域名是否https协议,如是请将其改为http完成一切操作之后即可畅游互联网科学冲浪了~]]></content>
      <categories>
        <category>随意折腾</category>
      </categories>
      <tags>
        <tag>文明上网</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
</search>
